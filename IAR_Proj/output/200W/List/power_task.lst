###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       03/Apr/2019  13:33:09
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c
#    Command line =  
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c" -D
#        XMC1301_T038x0064 -D OT_NFC_IP67_200W -D NDEBUG -D ENABLT_WDT -D
#        ENABLE_COMM -D ENABLE_USART -D nDEBUG_PRINT -D nDEBUG_VERSION -D
#        MODULE_I2C -D MODULE_M24LRxx -D MODULE_NFC -D MODULE_NFC_DALI -D
#        ENASTRO -D NO_FAST_TIME_ASTRO -D NO_EN_CLM_TIME_FAST -D ENABLE_OVP -D
#        ENABLE_MOBILE -D ENABLE_ONE2TEN -D BYTEORDER_LITTLE_ENDIAN -D
#        AVAILABLE_PORTS_NUMBER=3 -D FW_HIGH=01 -D FW_LOW=02 -D ENASTRO -D
#        MPC_O2T_DEFAULT_SETTINGS -D MPC_O2T_DEFAULT_BOUNDARIES -lc "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List" -o "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\IAR ARM
#        7.8\arm\INC\c\DLib_Config_Normal.h" -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\inc\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Driver\inc\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\devices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\driver_ot\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\fileTank\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\M24LRxx\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\"
#        -I PROJ_DIR$\..\Application\src\modules\NVM\api\ -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_xmc1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\currentset\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\DaliServices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\HW\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Modules\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Optional\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Services\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Acl\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\Legacy\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Clm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Csm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Info\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSK\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\O2T\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\AstroDim\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSKEncryption\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Power\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\EOL\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NFC\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\I2C\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC16\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\hwdrivers\XMC1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -Ol
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List\power_task.lst
#    Object file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj\power_task.o
#
###############################################################################

C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c
      1          /*
      2          ***************************************************************************************************
      3          *                               Output Power Control Loop Task
      4          *
      5          * File   : power_task.c
      6          * Author : Douglas Xie
      7          * Date   : 2016.04.26
      8          ***************************************************************************************************
      9          * Copyright (C) 2016 OSRAM Asia Pacific Management Company.  All rights reserved.
     10          ***************************************************************************************************
     11          */
     12          
     13          /* Include Head Files ---------------------------------------------------------------------------*/
     14          #include "power_task.h"

  #warning ::::::::::::::::::::::::::: Using original LEDset resistor (wrong for MP) :::::::::::::::::::::::::::
   ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",86  Warning[Pe1105]: 
          #warning directive: ::::::::::::::::::::::::::: Using original LEDset
          resistor (wrong for MP) :::::::::::::::::::::::::::

  #warning ::::::::::::::::::::::::::: Using original LEDset resistor (wrong for MP) :::::::::::::::::::::::::::
   ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",86  Warning[Pe1105]: 
          #warning directive: ::::::::::::::::::::::::::: Using original LEDset
          resistor (wrong for MP) :::::::::::::::::::::::::::
     15          #include "stdlib.h"
     16          /* Macro Defines --------------------------------------------------------------------------------*/
     17          
     18          /* Private Variable -----------------------------------------------------------------------------*/
     19          /* OVP & OCP counter for active protection function */
     20          uint8_t  g_OVP_counter = 0;
     21          uint8_t  g_OCP_counter = 0;
     22          
     23          /* Target Current Get from NFC Tag */
     24          uint16_t g_target_current = 0; 
     25          uint16_t g_max_voltage = 0; 
     26          uint16_t g_min_current = IOUT_MIN; 
     27          uint16_t g_astro_dimming_level = POWER_MAX_DIMMING;     /* 0.01% */
     28          uint16_t g_constant_lumen = POWER_MAX_DIMMING;          /* 0.01% */
     29          uint16_t g_eol_dimming_level = POWER_MAX_DIMMING;       /* 0.01% */
     30          uint16_t g_one2ten_dimming_level = POWER_MAX_DIMMING;   /* 0.01% */
     31          uint32_t g_s_period=0, g_a_period=30000;                /*period*/
     32          /* Power Control Loop State */
     33          Power_State_t g_control_loop_state = POWER_STATE_KEEP;
     34          
     35          /* Current Adjustment Speed Choose Threshold */
     36          uint16_t g_iout_threshold_high = 0;
     37          uint16_t g_iout_threshold_mid = 0;
     38          uint16_t g_iout_threshold_low = 0;
     39          
     40          /* PWM Stable Range */
     41          uint16_t g_pwm_stable_uout = PWM_STABLE_UOUT_0;
     42          uint16_t g_pwm_stable_iout = PWM_STABLE_IOUT_0;
     43          
     44          /* Output Current Stable Flag */
     45          uint8_t g_current_stable_flag = OUTPUT_UNSTABLE;
     46          
     47          /* Max PWM Duty Table */
     48          uint16_t g_max_pwm_duty = PWM_DUTY_FULL; /* default 100.0% */
     49          uint8_t g_max_duty_enable = 0;
     50          
     51          /* Uout and Iout Real Value */
     52          uint16_t g_uout_real = 0;       /* real voltage output value */
     53          uint16_t g_iout_real = 0;       /* real current output value */
     54          
     55          /* Uout and Iout Real Value */
     56          uint16_t g_uout_avg_adc = 0;    /* voltage average adc */
     57          uint16_t g_iout_avg_adc = 0;    /* current average adc */
     58          uint16_t g_one2ten_avg_adc = 0; /* 1-10V input average adc */
     59          
     60          /* Global Variable ------------------------------------------------------------------------------*/
     61          uint16_t g_current_a=0;
     62          uint8_t s_flag_off=0;
     63          uint8_t s_one_ten_update=0;
     64          /* Function Declaration -------------------------------------------------------------------------*/
     65          
     66          /* Output Power Control Function Implement ------------------------------------------------------*/
     67          
     68          /*******************************************************************************
     69          * @Brief   Output Power Control Loop Initial
     70          * @Param   
     71          * @Note    Config ADC moudle
     72          * @Return  
     73          *******************************************************************************/
     74          void Power_TaskInit(void)
     75          {           
     76              /* Global vairable initial */
     77              g_OVP_counter = 0;
     78              g_OCP_counter = 0;
     79              g_control_loop_state = POWER_STATE_KEEP;
     80               
     81              /* Set to global variable */
     82              Power_SetCurrent(g_target_current, SET_MODE_POWER_ON);
     83              
     84              /* Start timer for set real load voltage */
     85              SWT_StartTimer(SWT_ID_SET_LOAD, SET_LOAD_VOL_TIME);
     86              
     87              Filter_Init();
     88          }
     89          
     90          
     91          /*******************************************************************************
     92          * @Brief   Get Output Power Level
     93          * @Param   [in]target_current: user current setting value, unit is mA
     94          * @Note    Get output current level for control loop choosing threshold
     95          * @Return  Power_Level_t type level
     96          *******************************************************************************/
     97          Power_Level_t Power_GetPowerLevel(uint16_t target_current)
     98          {
     99              Power_Level_t level = POWER_LEVEL_0;
    100              
    101              if(target_current < CURRENT_LEVEL_0)
    102              {
    103                  level = POWER_LEVEL_0;
    104              }    
    105              else if(target_current < CURRENT_LEVEL_1)
    106              {
    107                  level = POWER_LEVEL_1;
    108              }
    109              else if(target_current < CURRENT_LEVEL_2)
    110              {
    111                  level = POWER_LEVEL_2;
    112              }
    113              else if(target_current < CURRENT_LEVEL_3)
    114              {
    115                  level = POWER_LEVEL_3;
    116              }
    117              else if(target_current < CURRENT_LEVEL_4)
    118              {
    119                  level = POWER_LEVEL_4;
    120              }
    121              else if(target_current < CURRENT_LEVEL_5)
    122              {
    123                  level = POWER_LEVEL_5;
    124              }
    125              else if(target_current < CURRENT_LEVEL_6)
    126              {
    127                  level = POWER_LEVEL_6;
    128              }
    129              else if(target_current < CURRENT_LEVEL_7)
    130              {
    131                  level = POWER_LEVEL_7;
    132              }
    133              else if(target_current < CURRENT_LEVEL_8)
    134              {
    135                  level = POWER_LEVEL_8;
    136              }
    137              else if(target_current < CURRENT_LEVEL_9)
    138              {
    139                  level = POWER_LEVEL_9;
    140              }
    141              else if(target_current < CURRENT_LEVEL_10)
    142              {
    143                  level = POWER_LEVEL_10;
    144              }
    145              else if(target_current < CURRENT_LEVEL_11)
    146              {
    147                  level = POWER_LEVEL_11;
    148              }
    149              else
    150              {
    151                  level = POWER_LEVEL_12;
    152              }
    153              
    154              return level;
    155          }
    156          
    157          
    158          /*******************************************************************************
    159          * @Brief   Get Control Initial PWM Duty
    160          * @Param   [in]level: target current level
    161          * @Note    Get control initial pwm duty according to level
    162          * @Return  
    163          *******************************************************************************/
    164          uint16_t Power_GetControlInitDuty(Power_Level_t level)
    165          {
    166              uint16_t pwm_duty = 0;
    167              
    168          
    169              /* Get control initial pwm duty according to level */
    170              switch(level)
    171              {
    172              case POWER_LEVEL_0:
    173                  pwm_duty = INIT_CTRL_DUTY_0;
    174                  break;
    175          
    176              case POWER_LEVEL_1:
    177                  pwm_duty = INIT_CTRL_DUTY_1;
    178                  break;
    179                  
    180              case POWER_LEVEL_2:
    181                  pwm_duty = INIT_CTRL_DUTY_2;
    182                  break;   
    183                  
    184              case POWER_LEVEL_3:
    185                  pwm_duty = INIT_CTRL_DUTY_3;
    186                  break;  
    187                  
    188              case POWER_LEVEL_4:
    189                  pwm_duty = INIT_CTRL_DUTY_4;
    190                  break;  
    191                  
    192              case POWER_LEVEL_5:
    193                  pwm_duty = INIT_CTRL_DUTY_5;
    194                  break;  
    195                  
    196              case POWER_LEVEL_6:
    197                  pwm_duty = INIT_CTRL_DUTY_6;
    198                  break;  
    199                  
    200              case POWER_LEVEL_7:
    201                  pwm_duty = INIT_CTRL_DUTY_7;
    202                  break;  
    203                  
    204              case POWER_LEVEL_8:
    205                  pwm_duty = INIT_CTRL_DUTY_8;
    206                  break; 
    207                  
    208              case POWER_LEVEL_9:
    209                  pwm_duty = INIT_CTRL_DUTY_9;
    210                  break; 
    211                          
    212              case POWER_LEVEL_10:
    213                  pwm_duty = INIT_CTRL_DUTY_10;
    214                  break; 
    215          
    216              case POWER_LEVEL_11:
    217                  pwm_duty = INIT_CTRL_DUTY_11;
    218                  break; 
    219          
    220              case POWER_LEVEL_12:
    221                  pwm_duty = INIT_CTRL_DUTY_12;
    222                  break; 
    223          
    224              default:
    225                  pwm_duty = INIT_CTRL_DUTY_1;
    226                  break; 
    227              }
    228              
    229              return pwm_duty;
    230          }
    231          
    232          
    233          /*******************************************************************************
    234          * @Brief   Get OCP Trigger Point PWM Duty
    235          * @Param   
    236          * @Note    Get OCP trigger point pwm duty according to target current
    237          * @Return  
    238          *******************************************************************************/
    239          uint16_t Power_GetOCPTriggerDuty(void)
    240          {
    241              uint16_t pwm_duty = 0;
    242              uint16_t ocp_current = 0;
    243              
    244              /* Get OCP current */
    245          #if 0
    246              ocp_current = g_target_current + OCP_TRIGGER_EXCEED;
    247          #else
    248              ocp_current = OCP_CURRENT_CONST;
    249          #endif
    250              
    251              /* Calculate OCP trigger point pwm duty */
    252              pwm_duty = (uint16_t)((OCP_TO_DUTY_D2 * ocp_current + OCP_TO_DUTY_D1) * ocp_current + OCP_TO_DUTY_D0);
    253              
    254              return pwm_duty;
    255          }
    256          
    257          
    258          /*******************************************************************************
    259          * @Brief   Get OVP Trigger Point PWM Duty
    260          * @Param   
    261          * @Note    Get OVP trigger point pwm duty according to target max voltage
    262          * @Return  
    263          *******************************************************************************/
    264          uint16_t Power_GetOVPTriggerDuty(void)
    265          {
    266              uint16_t pwm_duty = 0;
    267              uint16_t ovp_voltage = 0;
    268              
    269              /* Get OVP voltage */
    270              ovp_voltage = g_max_voltage + OVP_TRIGGER_EXCEED;
    271              
    272              /* Calculate OCP trigger point pwm duty */
    273              pwm_duty = (uint16_t)((OVP_TO_DUTY_E2 * ovp_voltage + OVP_TO_DUTY_E1) * ovp_voltage + OVP_TO_DUTY_E0);
    274              
    275              return pwm_duty;
    276          }
    277          
    278          
    279          /*******************************************************************************
    280          * @Brief   Prepare OVP and OCP Reference
    281          * @Param   
    282          * @Note    Read NFC tag and get OVP OCP reference before loop task begin
    283          * @Return  
    284          *******************************************************************************/
    285          void Power_PrepareReference(void)
    286          {
    287          #ifdef DEBUG_VERSION
    288              uint8_t  state = ERROR;
    289              uint8_t  eep_data[4] = {0, 0, 0, 0};
    290              uint16_t input_current = 0;
    291              
    292              /* Read current setting from NFC tag */
    293              state = Tag_ReadEEP(0x0000, 4, eep_data);
    294          
    295              /* Select initial PWM duty according to target current */
    296              if(state == OK)
    297              {
    298                  /* Get current setting value */
    299                  input_current = eep_data[0] * 1000 + 
    300                                  eep_data[1] * 100 + 
    301                                  eep_data[2] * 10 + 
    302                                  eep_data[3];    
    303                  
    304                  /* Set to global variable */
    305                  Power_SetCurrent(input_current, SET_MODE_NORMAL);
    306                  
    307                  USART_PrintInfo("\nread tag success\n\n");
    308              }
    309              else
    310              {
    311                  /* Set default output current */
    312                  Power_SetCurrent(POWER_DEFALUT_CURRENT, SET_MODE_NORMAL);
    313              
    314                  USART_PrintInfo("\nread tag error\n\n");
    315              }
    316              
    317              /* Write firmware version to NFC tag */
    318              eep_data[0] = FW_VERSION_MAJOR;
    319              eep_data[1] = FW_VERSION_MINOR;
    320              eep_data[2] = HW_VERSION_MAJOR;
    321              eep_data[3] = HW_VERSION_MINOR;
    322              state = Tag_WriteEEP(0x0008, 4, eep_data);  /* write in block 2, SW + HW */
    323          #endif /* DEBUG_VERSION */
    324          }
    325          
    326          /*******************************************************************************
    327          * @Brief   Set Target Output Power Current
    328          * @Param   [in]target_current: user current setting value, unit is mA
    329          *          [in]mode: SET_MODE_NORMAL / SET_MODE_POWER_ON
    330          * @Note    set target current value to variable and calculate max_voltage
    331          *          provide a init pwm duty according to the target current
    332          *          update OCP & OVP trigger voltage
    333          * @Return  
    334          *******************************************************************************/
    335          void Power_SetCurrent(uint16_t target_current, uint8_t mode)
    336          {
    337              uint16_t ctrl_duty = 0;
    338              uint16_t ocp_duty = 0;
    339              uint16_t ovp_duty = 0;
    340              Power_Level_t power_level = POWER_LEVEL_1;
    341             //target_current=70;// add testing value Moon
    342              /* Validate input current setting */
    343              if(target_current < g_min_current)
    344              {
    345                  /* Limit to minimum value */
    346                  target_current = g_min_current;
    347              }
    348              else if(target_current > IOUT_MAX)
    349              {
    350                  /* Limit to maximum value */
    351                  target_current = IOUT_MAX;
    352              }
    353              
    354              /* Update control loop current adjustment speed threshold */
    355              if(target_current < IOUT_DIVIDER_1_0)
    356              {
    357                  g_iout_threshold_high = IOUT_THRESHOLD_HIGH_0;
    358                  g_iout_threshold_mid = IOUT_THRESHOLD_MID_0;
    359                  g_iout_threshold_low = IOUT_THRESHOLD_LOW_0;  
    360                  g_pwm_stable_uout = PWM_STABLE_UOUT_0;
    361                  g_pwm_stable_iout = PWM_STABLE_IOUT_0;
    362              }
    363              else if(target_current < IOUT_DIVIDER_2_1)
    364              {
    365                  g_iout_threshold_high = IOUT_THRESHOLD_HIGH_1;
    366                  g_iout_threshold_mid = IOUT_THRESHOLD_MID_1;
    367                  g_iout_threshold_low = IOUT_THRESHOLD_LOW_1;   
    368                  g_pwm_stable_uout = PWM_STABLE_UOUT_1;
    369                  g_pwm_stable_iout = PWM_STABLE_IOUT_1;
    370              }
    371              else
    372              {
    373                  g_iout_threshold_high = IOUT_THRESHOLD_HIGH_2;
    374                  g_iout_threshold_mid = IOUT_THRESHOLD_MID_2;
    375                  g_iout_threshold_low = IOUT_THRESHOLD_LOW_2;   
    376                  g_pwm_stable_uout = PWM_STABLE_UOUT_2;
    377                  g_pwm_stable_iout = PWM_STABLE_IOUT_2;
    378              }
    379          
    380              /* Update when target current change */
    381              if((target_current != g_target_current) || (mode == SET_MODE_POWER_ON))
    382              {
    383                  /* Calculate average ADC */
    384                  ADC_CalculateAverage();
    385                  
    386                  /* Get raw data(average ADC) */
    387                  g_iout_avg_adc = ADC_GetAverage(ADC_CHANNEL_IOUT);
    388                  g_uout_avg_adc = ADC_GetAverage(ADC_CHANNEL_UOUT);
    389                  
    390                  /* Update 1-10V Dimming Level */
    391                  g_one2ten_avg_adc = ADC_GetAverage(ADC_CHANNEL_DIM);
    392                  if(g_one2ten_avg_adc<ONE_TEN_LOW_VOLTAGE)
    393                      g_one2ten_avg_adc=ONE_TEN_LOW_VOLTAGE;
    394                  if(g_one2ten_avg_adc>ONE_TEN_HIGH_VOLTAGE)
    395                      g_one2ten_avg_adc=ONE_TEN_HIGH_VOLTAGE;     
    396                    //g_one2ten_avg_adc=ONE_TEN_LOW_VOLTAGE;
    397                  Power_UpdateOne2TenDimming(g_one2ten_avg_adc);
    398          #ifndef ENABLE_ONE2TEN
    399                  g_one2ten_dimming_level = POWER_MAX_DIMMING;
    400          #endif
    401                  //g_one2ten_dimming_level=10000;
    402                  
    403                  /*-------- Update Target Current -------------------------------------*/
    404                  /* Reset current to not stable */
    405                  g_current_stable_flag = OUTPUT_UNSTABLE; 
    406                  g_max_duty_enable = 0;
    407                  g_max_pwm_duty = PWM_DUTY_FULL;
    408              
    409                  /* Set to global variable */
    410                  g_target_current = target_current;
    411                  g_max_voltage = (uint16_t)((uint32_t)OUTPUT_POWER * POWER_UOUT_TOLERANCE / g_target_current);
    412                  
    413                  /* Global max voltage limit*/
    414                  if(g_max_voltage > UOUT_MAX)
    415                  {
    416                      g_max_voltage = (uint16_t)(UOUT_MAX * POWER_UOUT_TOLERANCE);
    417                  }
    418               
    419                  /*-------- Get New Target PWM Duty -----------------------------------*/
    420                  /* Start current with astro dimming control */
    421                  target_current = (uint16_t)((uint32_t)g_target_current * g_astro_dimming_level / POWER_MAX_DIMMING);
    422                  /* Start current with constant lumen control */
    423                  target_current = (uint16_t)((uint32_t)target_current * g_constant_lumen / POWER_MAX_DIMMING);
    424                  /* Start current with eol dimming level */
    425                  target_current = (uint16_t)((uint32_t)target_current * g_eol_dimming_level / POWER_MAX_DIMMING);
    426          #ifdef ENABLE_ONE2TEN
    427                  /* Target current with 1-10V dimming level */
    428                  target_current = (uint16_t)((uint32_t)target_current * g_one2ten_dimming_level / POWER_MAX_DIMMING);
    429          #endif
    430                  
    431                  if(target_current < g_min_current)
    432                  {
    433                      target_current = g_min_current;
    434                  }
    435                  
    436                  /* Update power level */
    437                  target_current=(target_current*g_one2ten_dimming_level/10000);
    438          
    439                  power_level = Power_GetPowerLevel(target_current);        
    440                  
    441                  /* Get initial pwm duty accroding to power level */
    442                  
    443                  ctrl_duty = Power_GetControlInitDuty(power_level); 
    444                  
    445                  /* Get ocp trigger point pwm duty accroding to target current */
    446                  ocp_duty = Power_GetOCPTriggerDuty(); 
    447                  
    448                  /* Get ovp trigger point pwm duty accroding to target max voltage */
    449                  ovp_duty = Power_GetOVPTriggerDuty(); 
    450                  
    451                  /*-------- Update PWM Duty -------------------------------------------*/
    452                  if(mode == SET_MODE_POWER_ON)
    453                  {
    454                      if(PWM_GetProtectState() != PWM_STATE_PROTECT)
    455                      {
    456                          /* Provide init pwm duty for fast adjustment */
    457                          PWM_SetDuty(PWM_ID_CH_CTRL, ctrl_duty, PWM_MODE_LIMIT);
    458                      }
    459                  }
    460                  
    461                  /* Update OCP trigger voltage for short protection */
    462                  PWM_SetDuty(PWM_ID_CH_OCP, ocp_duty, PWM_MODE_LIMIT);
    463                  
    464                  /* Update OVP trigger voltage for open protection */
    465                  PWM_SetDuty(PWM_ID_CH_OVP, ovp_duty, PWM_MODE_LIMIT);
    466              }
    467          }
    468          
    469          
    470          /*******************************************************************************
    471          * @Brief   Get Target Output Current
    472          * @Param  
    473          * @Return  target current that save in g_target_current
    474          *******************************************************************************/
    475          uint16_t Power_GetCurrent(void)
    476          {
    477              return g_target_current;
    478          }
    479          
    480          
    481          /*******************************************************************************
    482          * @Brief   Get Minmum Dimming Level
    483          * @Param   
    484          * @Note    calculate minmum dimming level according to the minmum iout and iset
    485          * @Return  minmum dimming level(percent with unit 0.01%)
    486          *******************************************************************************/
    487          uint16_t Power_GetMinLevel(void)
    488          {
    489              uint16_t minmum_level = 0;
    490              
    491              /* Calculate minmum dimming level */
    492              if(g_target_current != 0)
    493              {
    494                  minmum_level = (uint16_t)((uint32_t)g_min_current * 10000 / g_target_current);
    495              }
    496              else
    497              {
    498                  minmum_level = (uint16_t)((uint32_t)g_min_current * 10000 / IOUT_MAX);
    499              }
    500              
    501              return (minmum_level);
    502          }
    503          
    504          
    505          /*******************************************************************************
    506          * @Brief   Set Astro Dimming Level
    507          * @Param   [in]percent: dimming percent value, unit is 0.01%
    508          * @Note    set dimming value of dimming mode which are set from T4T
    509          * @Return  
    510          *******************************************************************************/
    511          void Power_SetAstroDimmingLevel(uint16_t percent)
    512          {
    513              /* Check input value */
    514              if(percent > POWER_MAX_DIMMING)
    515              {
    516                  percent = POWER_MAX_DIMMING;
    517              }
    518              
    519              if(g_astro_dimming_level != percent)
    520              {    
    521                  /* Set to global variable */
    522                  g_astro_dimming_level = percent;
    523                  
    524                  /* Reset current to not stable */
    525                  g_current_stable_flag = OUTPUT_UNSTABLE; 
    526                  g_max_duty_enable = 0;
    527                  g_max_pwm_duty = PWM_DUTY_FULL;
    528              } 
    529          }
    530          
    531          
    532          /*******************************************************************************
    533          * @Brief   Set Constant Lumen Value
    534          * @Param   [in]percent: constant lumen percent value, unit is 0.01%
    535          * @Note    set constant lumen dimming percent value which are set from T4T
    536          * @Return  
    537          *******************************************************************************/
    538          void Power_SetConstantLumenValue(uint16_t percent)
    539          {
    540              /* Check input value */
    541              if(percent > POWER_MAX_DIMMING)
    542              {
    543                  percent = POWER_MAX_DIMMING;
    544              }
    545              
    546              if(g_constant_lumen != percent)
    547              {
    548                  /* Set to global variable */
    549                  g_constant_lumen = percent;
    550                  
    551                  /* Reset current to not stable */
    552                  
    553                  g_current_stable_flag = OUTPUT_UNSTABLE; 
    554                  g_max_duty_enable = 0;
    555                  g_max_pwm_duty = PWM_DUTY_FULL;
    556              }
    557          }
    558          
    559          /*******************************************************************************
    560          * @Brief   Set EOL Dimming Level
    561          * @Param   [in]percent: eol dimming percentage value, unit is 0.01%
    562          * @Note    
    563          * @Return  
    564          *******************************************************************************/
    565          void Power_SetEolDimmingLevel(uint16_t percent)
    566          {
    567              /* Check input value */
    568              if(percent > POWER_MAX_DIMMING)
    569              {
    570                  percent = POWER_MAX_DIMMING;
    571              }
    572              
    573              if(g_eol_dimming_level != percent)
    574              {
    575                  /* Set to global variable */
    576                  g_eol_dimming_level = percent;
    577                  
    578                  /* Reset current to not stable */
    579                  g_current_stable_flag = OUTPUT_UNSTABLE; 
    580                  g_max_duty_enable = 0;
    581                  g_max_pwm_duty = PWM_DUTY_FULL;
    582              }
    583          }
    584          
    585          
    586          /*******************************************************************************
    587          * @Brief   Update 1_10V Dimming Level
    588          * @Param   [in]adc: 1-10V input voltage adc
    589          * @Note    
    590          * @Return  
    591          *******************************************************************************/
    592          void Power_UpdateOne2TenDimming(uint16_t adc)
    593          {
    594              float level = 0;
    595              uint16_t difference = 0,next_level=0;
    596              uint32_t temp_data=0;
    597              static int32_t temp1=0;
    598              static int32_t temp2=0;
    599              static uint32_t dim_level_1_10=0;
    600              static uint32_t s_min_level=0;
    601              /* Calculate 1-10V dimming level */
    602              
    603              if(O2T_GetEnableConfig()==0) //TDL
                        ^
Warning[Pe223]: function "O2T_GetEnableConfig" declared implicitly
    604              {
    605                g_one2ten_dimming_level= POWER_MAX_DIMMING;     
    606              }
    607              else                                          //TDL
    608              {
    609                //s_min_level=(mem_bank_nfc.mem_bank_1_10.Level_h_1_10<<8)+mem_bank_nfc.mem_bank_1_10.Level_l_1_10; //TDL
    610                s_min_level=O2T_GetMinDimLevel();
                                   ^
Warning[Pe223]: function "O2T_GetMinDimLevel" declared implicitly

      uint16_t difference = 0,next_level=0;
                              ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",595  Warning[Pe550]: 
          variable "next_level" was set but never used
    611                s_min_level*=10000;
    612                s_min_level>>=15;
    613                
    614                temp_data=(POWER_MAX_DIMMING-s_min_level)*(adc-ONE_TEN_LOW_VOLTAGE);
    615                level=temp_data;
    616                level/=(ONE_TEN_HIGH_VOLTAGE-ONE_TEN_LOW_VOLTAGE);
    617                level+=s_min_level;
    618                //level = (float)ONE2TEN_PARAM_C1 * adc + (float)ONE2TEN_PARAM_C0;
    619                /********Get level filter value******/
    620                temp1 =(uint32_t)level;//
    621                
    622                if(temp1>ONE2TEN_UPPER_LIMIT)
    623                  
    624                  temp1=ONE2TEN_UPPER_LIMIT;
    625                
    626                if(temp1<ONE2TEN_LOWER_LIMIT)
    627                  
    628                  temp1=ONE2TEN_LOWER_LIMIT;
    629                
    630                temp2 += (((temp1<<10)- temp2)>>4);
    631                
    632                dim_level_1_10=temp2>>10;
    633                
    634                if(abs(dim_level_1_10-(uint16_t)(level))<50)
    635                {
    636                  level=(float)dim_level_1_10;
    637                }
    638                /* Dimming level change difference */
    639                if(level > g_one2ten_dimming_level)
    640                {
    641                  difference = (uint16_t)level - g_one2ten_dimming_level;
    642                }
    643                else
    644                {
    645                  difference = g_one2ten_dimming_level - (uint16_t)level;
    646                }
    647                
    648                /* Validate dimming result */
    649                if(level > ONE2TEN_UPPER_LIMIT)
    650                {
    651                  difference = ONE2TEN_UPPER_LIMIT - g_one2ten_dimming_level;        
    652                  next_level = ONE2TEN_UPPER_LIMIT;
    653                }
    654                else if(level < ONE2TEN_LOWER_LIMIT)
    655                {
    656                  difference = g_one2ten_dimming_level - ONE2TEN_LOWER_LIMIT;        
    657                  next_level = ONE2TEN_LOWER_LIMIT;
    658                }
    659                else
    660                {
    661                  next_level = (uint16_t)level;
    662                }
    663                
    664                /* Update dimming level with rank filter */
    665                //g_one2ten_dimming_level = Filter_Input(next_level);//moon update
    666                g_one2ten_dimming_level=(uint16_t)level;
    667                //g_one2ten_dimming_level=next_level;
    668                //g_one2ten_dimming_level=1000; //10% testing using
    669                /* Stable flag update for speed up */
    670                //g_one2ten_dimming_level=5000;
    671                if(difference >= POWER_DIM_UNSTABLE_DUTY)
    672                {
    673                  s_one_ten_update=1;
    674                }
    675                {
    676                  g_current_stable_flag = OUTPUT_UNSTABLE; 
    677                  g_max_duty_enable = 0;
    678                  g_max_pwm_duty = PWM_DUTY_FULL;
    679                }
    680              }
    681          }
    682          
    683          /*******************************************************************************
    684          * @Brief   Get Power Loop State
    685          * @Param   
    686          * @Note    
    687          * @Return  power loop state
    688          *******************************************************************************/
    689          Power_State_t Power_GetPowerLoopState(void)
    690          {
    691              return g_control_loop_state;
    692          }
    693          
    694          /*******************************************************************************
    695          * @Brief   Get Real Output Current Value
    696          * @Param   
    697          * @Note    
    698          * @Return  g_iout_real
    699          *******************************************************************************/
    700          uint16_t Power_GetRealIout(void)
    701          {
    702              return g_iout_real;
    703          }
    704          
    705          /*******************************************************************************
    706          * @Brief   Get Real Output Voltage Value
    707          * @Param   
    708          * @Note    
    709          * @Return  g_uout_real
    710          *******************************************************************************/
    711          uint16_t Power_GetRealUout(void)
    712          {
    713              return g_uout_real;
    714          }
    715          
    716          /*******************************************************************************
    717          * @Brief   Get Output Current Average ADC
    718          * @Param   
    719          * @Note    
    720          * @Return  g_iout_real
    721          *******************************************************************************/
    722          uint16_t Power_GetIoutAvgADC(void)
    723          {
    724              return g_iout_avg_adc;
    725          }
    726          
    727          /*******************************************************************************
    728          * @Brief   Get Output Voltage Average ADC
    729          * @Param   
    730          * @Note    
    731          * @Return  g_uout_real
    732          *******************************************************************************/
    733          uint16_t Power_GetUoutAvgADC(void)
    734          {
    735              return g_uout_avg_adc;
    736          }
    737          
    738          /*******************************************************************************
    739          * @Brief   Get Constant Lumen Dimming Level Value
    740          * @Param   
    741          * @Note    
    742          * @Return  g_constant_lumen
    743          *******************************************************************************/
    744          uint16_t Power_GetConstantLumenValue(void)
    745          {
    746              return g_constant_lumen;
    747          }
    748          
    749          /*******************************************************************************
    750          * @Brief   Get Astro Dimming Level
    751          * @Param   
    752          * @Note    
    753          * @Return  g_astro_dimming_level
    754          *******************************************************************************/
    755          uint16_t Power_GetAstroDimmingLevel(void)
    756          {
    757              return g_astro_dimming_level;
    758          }
    759          
    760          /*******************************************************************************
    761          * @Brief   Get EOL Dimming Level
    762          * @Param   
    763          * @Note    
    764          * @Return  g_eol_dimming_level
    765          *******************************************************************************/
    766          uint16_t Power_GetEolDimmingLevel(void)
    767          {
    768              return g_eol_dimming_level;
    769          }
    770          
    771          /*******************************************************************************
    772          * @Brief   Get 1_10V Dimming Level
    773          * @Param   
    774          * @Note    
    775          * @Return  g_one2ten_dimming_level
    776          *******************************************************************************/
    777          uint16_t Power_GetOne2TenDimming(void)
    778          {
    779              return g_one2ten_dimming_level;
    780          }
    781          
    782          /*******************************************************************************
    783           * @Brief   Output Power Control Loop Task
    784           * @Param   
    785           * @Note    Power max 200W
    786           *                  Measure range    |   Actural range
    787           *          Iout    0.07V - 0.28V    |   0.35A - 1.4A 
    788           *          Uout    2.84V - 1.22V    |   333V  - 143V
    789           * @Return  
    790           *******************************************************************************/
    791          void Power_ControlLoopTask(void)
    792          {
    793              uint8_t i = 0;
    794              uint16_t target_current = 0;    /* target current with dimming */
    795              uint16_t difference = 0;        /* difference between real and target value */
    796              uint16_t pwm_duty = 0;
    797              uint16_t adjust_speed = 0;
    798              static uint8_t s_hiccup_counter = 0;
    799              static int32_t temp1=0;
    800              static int32_t temp2=0;
    801              static uint32_t i_out_roll=0;
    802              static int32_t temp3=0;
    803              static int32_t temp4=0;
    804              static uint32_t u_out_roll=0;
    805              static uint16_t g_set_current=400,g_test_current=0;
    806              static uint8_t delay=0;
    807              static uint32_t g_power_current=0,g_power_current_pre=0;
    808              int32_t test1;
    809          
    810              uint8_t  tx_buff[20]; 
    811              uint16_t duty = 0;
    812              uint16_t avg_adc_iout = 0;
    813              uint16_t avg_adc_uout = 0;
    814              
    815          #ifdef DEBUG_PRINT
    816          #endif
    817                   //DaliBallast_CyclicTask();    
    818              /* Check if task has beed created */
    819              if(System_CheckTask(SYS_TASK_LOOP) == SYS_TASK_DISABLE)
    820              {
    821                  return;
    822              }
    823              
    824              /* Don't run control loop while in protect state */
    825              if(PWM_GetProtectState() == PWM_STATE_PROTECT)
    826              {
    827                  return;
    828              }
    829          
    830                  
    831              /*-------- Get Output Average Result from ADC Module -----------------------*/    
    832              /* Calculate average ADC */
    833              ADC_CalculateAverage();
    834              
    835              /* Get raw data(average ADC) */
    836              g_iout_avg_adc = ADC_GetAverage(ADC_CHANNEL_IOUT);
    837              g_uout_avg_adc = ADC_GetAverage(ADC_CHANNEL_UOUT);
    838              
    839              
    840                  uint8_t *pinfo; //add test
    841              sprintf((char*)tx_buff, "%d \n", g_iout_avg_adc);
                     ^
Warning[Pe223]: function "sprintf" declared implicitly

      uint8_t i = 0;
              ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",793  Warning[Pe177]: 
          variable "i" was declared but never referenced

      static uint16_t g_set_current=400,g_test_current=0;
                      ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",805  Warning[Pe177]: 
          variable "g_set_current" was declared but never referenced

      static uint16_t g_set_current=400,g_test_current=0;
                                        ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",805  Warning[Pe550]: 
          variable "g_test_current" was set but never used

      uint16_t duty = 0;
               ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",811  Warning[Pe177]: 
          variable "duty" was declared but never referenced

      uint16_t avg_adc_iout = 0;
               ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",812  Warning[Pe177]: 
          variable "avg_adc_iout" was declared but never referenced

      uint16_t avg_adc_uout = 0;
               ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\power_task.c",813  Warning[Pe177]: 
          variable "avg_adc_uout" was declared but never referenced
    842              pinfo=tx_buff;
    843                  while(*pinfo != '\0')
    844              {
    845                  XMC_UART_CH_Transmit(USART_CHANNEL, *pinfo);
    846                  pinfo++;
    847              }
    848              /* Update 1-10V Dimming Level */
    849              if(SWT_CheckTimer(SWT_ID_ONE2TEN) != SWT_STATUS_OK)
    850              {
    851                  SWT_StartTimer(SWT_ID_ONE2TEN, ONE2TEN_UPDATE_TIME);
    852                  g_one2ten_avg_adc = ADC_GetAverage(ADC_CHANNEL_DIM);
    853                  if(g_one2ten_avg_adc<ONE_TEN_LOW_VOLTAGE)
    854                      g_one2ten_avg_adc=ONE_TEN_LOW_VOLTAGE;
    855                  if(g_one2ten_avg_adc>ONE_TEN_HIGH_VOLTAGE)
    856                      g_one2ten_avg_adc=ONE_TEN_HIGH_VOLTAGE; 
    857                    //g_one2ten_avg_adc=ONE_TEN_LOW_VOLTAGE;//Add Moon
    858                  Power_UpdateOne2TenDimming(g_one2ten_avg_adc);
    859              }
    860          #ifndef ENABLE_ONE2TEN
    861              g_one2ten_dimming_level = POWER_MAX_DIMMING;
    862          #endif
    863              
    864              /* Convert Iout ADC to Real Current in mA */
    865              g_iout_real = (uint16_t)((((IOUT_PARAM_A2 * g_iout_avg_adc) + IOUT_PARAM_A1) * g_iout_avg_adc) + IOUT_PARAM_A0);
    866              
    867              /* Convert Uout ADC to Real Voltage in V */
    868              g_uout_real = (uint16_t)((((UOUT_PARAM_B2 * g_uout_avg_adc) + UOUT_PARAM_B1) * g_uout_avg_adc) + UOUT_PARAM_B0);
    869              g_uout_real*=UOUT_COMPENSATION;
    870              //g_uout_real=200;
    871              g_test_current=g_iout_real;
    872              /* Iout compensation when disable DEBUG PRINT */
    873              g_iout_real = (uint32_t)(g_iout_real * IOUT_COMPENSATION + IOUT_OFFSET);
    874                  /* Get stable vlaue for I_out Add by moon 2018.3.9*/   
    875              temp1=g_iout_real;
    876              temp2 += (((temp1<<10)- temp2)>>2);
    877              i_out_roll=temp2>>10;
    878              if(abs(i_out_roll-g_iout_real)<10)
    879              {
    880                  g_iout_real=i_out_roll;
    881              }
    882              /* Target current with dimming control */
    883              target_current = (uint16_t)((uint32_t)g_target_current * g_astro_dimming_level / POWER_MAX_DIMMING);
    884              /* Target current with constant lumen control */
    885              target_current = (uint16_t)((uint32_t)target_current * g_constant_lumen / POWER_MAX_DIMMING);
    886              /* Target current with eol dimming level */
    887              target_current = (uint16_t)((uint32_t)target_current * g_eol_dimming_level / POWER_MAX_DIMMING);
    888          #ifdef ENABLE_ONE2TEN
    889              /* Target current with 1-10V dimming level */
    890              target_current = (uint16_t)((uint32_t)target_current * g_one2ten_dimming_level / POWER_MAX_DIMMING);
    891              //target_current=1400;
    892              //target_current=g_set_current; //add test code moon
    893                  /* Update control loop current adjustment speed threshold */
    894          #endif    
    895              temp3=g_uout_real;
    896              temp4 += (((temp3<<10)- temp4)>>4);
    897              u_out_roll=temp4>>10;
    898              if(abs(u_out_roll-g_uout_real)<10)
    899              {
    900                g_uout_real=u_out_roll;
    901              }
    902              if(g_uout_real!=0&&g_iout_real>50)
    903              {
    904          #ifdef OT_NFC_IP67_200W
    905                g_power_current=(uint32_t)(OUTPUT_POWER*1.015/g_uout_real);// constant power control
    906          #else
    907                g_power_current=(uint32_t)(OUTPUT_POWER*1.002/g_uout_real);// constant power control
    908          #endif 
    909                
    910                if(abs(g_power_current-g_power_current_pre)<10)
    911                  g_power_current=g_power_current_pre;
    912              }
    913              else
    914              {
    915                g_power_current=target_current;
    916              }
    917              g_power_current_pre=g_power_current;
    918              
    919              if(target_current>g_power_current)
    920              {
    921                target_current=g_power_current;
    922              }
    923              
    924              if(target_current < IOUT_DIVIDER_1_0)
    925              {
    926                  g_iout_threshold_high = IOUT_THRESHOLD_HIGH_0;
    927                  g_iout_threshold_mid = IOUT_THRESHOLD_MID_0;
    928                  g_iout_threshold_low = IOUT_THRESHOLD_LOW_0;  
    929                  g_pwm_stable_uout = PWM_STABLE_UOUT_0;
    930                  g_pwm_stable_iout = PWM_STABLE_IOUT_0;
    931              }
    932              else if(target_current < IOUT_DIVIDER_2_1)
    933              {
    934                  g_iout_threshold_high = IOUT_THRESHOLD_HIGH_1;
    935                  g_iout_threshold_mid = IOUT_THRESHOLD_MID_1;
    936                  g_iout_threshold_low = IOUT_THRESHOLD_LOW_1;   
    937                  g_pwm_stable_uout = PWM_STABLE_UOUT_1;
    938                  g_pwm_stable_iout = PWM_STABLE_IOUT_1;
    939              }
    940              else
    941              {
    942                  g_iout_threshold_high = IOUT_THRESHOLD_HIGH_2;
    943                  g_iout_threshold_mid = IOUT_THRESHOLD_MID_2;
    944                  g_iout_threshold_low = IOUT_THRESHOLD_LOW_2;   
    945                  g_pwm_stable_uout = PWM_STABLE_UOUT_2;
    946                  g_pwm_stable_iout = PWM_STABLE_IOUT_2;
    947              }
    948              /*Add by moon ************************************/
    949          //    if(abs(g_iout_real-target_current)<20)
    950          //    {
    951          //    if(g_s_period>g_a_period)
    952          //        g_a_period+=2;
    953          //    else
    954          //        if(g_s_period<g_a_period)
    955          //            g_a_period-=2;
    956          //    }
    957               /*Add by moon ************************************/
    958              /* Power limit after startup */
    959              if(SWT_CheckTimer(SWT_ID_SET_LOAD) == SWT_STATUS_UP)
    960              {       
    961                  /* Update minimum output current 10% POWER */
    962                  g_min_current = (uint16_t)((uint32_t)OUTPUT_POWER * POWER_MIN_OUTPUT / g_uout_real / 100);
    963                  
    964                  /* Minimum current limit */
    965                  if(g_min_current > IOUT_MAX)
    966                  {
    967                      g_min_current = IOUT_MAX;
    968                  }
    969                  
    970                  if(g_min_current <= IOUT_MIN)
    971                  {
    972                      g_min_current = IOUT_MIN;
    973                  }
    974              }
    975          
    976              if(target_current < g_min_current)
    977              {
    978                  target_current = g_min_current;
    979              }
    980              if(target_current<70)
    981                target_current=70;
    982              g_current_a=target_current;
    983              //target_current=700; //test add Moon
    984          
    985              /*-------- Verify Current & Voltage Range ----------------------------------*/    
    986              /* Output current does not reach the target */
    987              if(g_iout_real < target_current)
    988              {
    989                  /* Output voltage not match the max output voltage */
    990                  if(g_uout_real < g_max_voltage+OVP_TRIGGER_EXCEED*3)//update FW OVP check point
    991                  {
    992                      if(g_uout_real < (g_max_voltage -  (uint32_t)g_max_voltage * g_pwm_stable_uout / 1000+OVP_TRIGGER_EXCEED*3))
    993                      {
    994                          /* PWM duty will increase */
    995                          g_control_loop_state = POWER_STATE_INCREASE;
    996                      }
    997                      else
    998                      {            
    999                          /* Keep PWM duty */
   1000                          g_control_loop_state = POWER_STATE_KEEP;
   1001                      }
   1002                  }
   1003                  /* Output voltage exceed the max output voltage */
   1004                  else if(g_uout_real > g_max_voltage)
   1005                  {
   1006                  #ifdef ENABLE_LOOP_OVP_OCP        
   1007                      if(g_uout_real >= (g_max_voltage + OVP_AVERAGE_EXCEED))
   1008                      {
   1009                          /* Output voltage exceed voltage limit, need OVP protection */
   1010                          g_control_loop_state = POWER_STATE_OVP;
   1011                          
   1012                      }
   1013                      else if(g_uout_real >= (g_max_voltage + g_max_voltage * g_pwm_stable_uout / 1000))
   1014                  #else
   1015                      if(g_uout_real >= (g_max_voltage + g_max_voltage * g_pwm_stable_uout / 1000))
   1016                  #endif
   1017                      {
   1018                          /* Output voltage exceed the upper limit,  PWM duty will decrease */
   1019                          g_control_loop_state = POWER_STATE_DECREASE;
   1020                      }
   1021                      else
   1022                      {
   1023                          /* Keep PWM duty */
   1024                          g_control_loop_state = POWER_STATE_KEEP;
   1025                      }
   1026                  }
   1027                  else
   1028                  {
   1029                      /* Output voltage reach the upper limit, keep the PWM duty */
   1030                      g_control_loop_state = POWER_STATE_KEEP;
   1031                  }
   1032              }
   1033              /* Output current exceed the target */
   1034              else if(g_iout_real > target_current)
   1035              {
   1036              #ifdef ENABLE_LOOP_OVP_OCP
   1037                  /* Output current exceed the target, PWM duty will decrease */
   1038                  if(g_iout_real > (target_current + OCP_AVERAGE_EXCEED))
   1039                  {
   1040                      /* Output current exceed limit and need OCP protection */
   1041                      g_control_loop_state = POWER_STATE_OCP;
   1042                  }
   1043                  else if(g_iout_real > (target_current + (uint32_t)target_current * g_pwm_stable_iout / 1000))
   1044              #else
   1045                  if(g_iout_real > (target_current +  (uint32_t)target_current * g_pwm_stable_iout / 1000))
   1046              #endif
   1047                  {
   1048                      /* Output current exceed target, PWM duty will decrease */
   1049                      g_control_loop_state = POWER_STATE_DECREASE;
   1050                  }
   1051                  else     
   1052                  {
   1053                      /* Keep PWM duty */
   1054                      g_control_loop_state = POWER_STATE_KEEP;
   1055                  }
   1056              }
   1057              else
   1058              {
   1059                  /* Output current reach the target, keep the PWM duty */
   1060                  g_control_loop_state = POWER_STATE_KEEP;
   1061                  s_one_ten_update=0;
   1062          
   1063              }
   1064              
   1065              
   1066              /*Current tolerance 10mA****/ //Add by Moon 2018.3,9
   1067              if(g_iout_real>target_current)
   1068                  test1=g_iout_real-target_current;
   1069              else
   1070                  test1=target_current-g_iout_real;
   1071              //test1=abs((int16_t)(g_iout_real-target_current));
   1072              if (test1<5)//current tolerance when current
   1073              {
   1074                  g_iout_real=target_current;
   1075                  g_control_loop_state = POWER_STATE_KEEP;
   1076                  s_one_ten_update=0;
   1077              }
   1078              else
   1079              {
   1080                  sprintf((char*)tx_buff, "%3d.%1d \n", g_iout_real);
   1081                  USART_PrintInfo(tx_buff);
   1082              }
   1083           /*power off judge**/   
   1084          #ifndef OT_NFC_IP67_100W 
   1085              if(s_flag_off==0)
   1086              {
   1087                if(delay++>50)
   1088                {
   1089                  delay=150;
   1090                  
   1091                  if(((g_iout_real+50)<target_current)&&(s_one_ten_update==0)&&(target_current<400))
   1092                  {
   1093                    s_flag_off=1;
   1094                    //PWM_EnterProtection();
   1095                    delay=0;
   1096                  }
   1097                }  
   1098              }
   1099          #endif   
   1100          //    uint8_t *pinfo; //add test
   1101          //    sprintf((char*)tx_buff, "%d \n", PWM_GetDuty(PWM_ID_CH_CTRL));
   1102          //    pinfo=tx_buff;
   1103          //        while(*pinfo != '\0')
   1104          //    {
   1105          //        XMC_UART_CH_Transmit(USART_CHANNEL, *pinfo);
   1106          //        pinfo++;
   1107          //    }
   1108              /*-------- Adjust PWM for Control Loop -------------------------------------*/
   1109              switch(g_control_loop_state)
   1110              {
   1111              case POWER_STATE_INCREASE:
   1112                  /* Clear OVP & OCP counter */
   1113                  g_OVP_counter = 0;
   1114                  g_OCP_counter = 0;
   1115                  
   1116                  /* Calculate the difference between real value and target value */
   1117                  difference = target_current - g_iout_real;
   1118                  
   1119                  /* Select Adjust Speed */
   1120                  /* Current unstable has full range speed */
   1121                  if(g_current_stable_flag != OUTPUT_STABLE)
   1122                  {
   1123                      if(difference < g_iout_threshold_low)
   1124                      {
   1125                          adjust_speed = PWM_SPEED_STEP;
   1126                          USART_PrintInfo("UP ");
   1127                      }
   1128                      else if(difference < g_iout_threshold_mid)
   1129                      {
   1130                          adjust_speed = PWM_SPEED_LOW;
   1131                          USART_PrintInfo("INC_L ");
   1132                      }
   1133                      else if(difference <g_iout_threshold_high)
   1134                      {
   1135                          adjust_speed = PWM_SPEED_MID;
   1136                          USART_PrintInfo("INC_M ");
   1137                      }
   1138                      else
   1139                      {
   1140                          adjust_speed = PWM_SPEED_HIGH;
   1141                          USART_PrintInfo("INC_H ");
   1142                      }
   1143                  }
   1144                  /* Current enter stable condition, only have two speed */
   1145                  else
   1146                  {
   1147                      if(difference < g_iout_threshold_low)
   1148                      {
   1149                          adjust_speed = PWM_SPEED_STEP;
   1150                          USART_PrintInfo("UP ");
   1151                      }
   1152                      else
   1153                      {
   1154                          adjust_speed = PWM_SPEED_LOW;
   1155                          USART_PrintInfo("INC_L ");
   1156                      }
   1157                  }
   1158                  
   1159                  /* Choose Adjust Mode and Update PWM Duty */
   1160                  if(adjust_speed == PWM_SPEED_STEP)
   1161                  {
   1162                      if(PWM_GetDuty(PWM_ID_CH_CTRL) <= g_max_pwm_duty)
   1163                      {
   1164                          /* Step adjust mode, use step up function for fine turning */
   1165                          PWM_DutyStepUp(PWM_ID_CH_CTRL, 1);//Moon change 1
   1166                      }
   1167                      else
   1168                      {
   1169                          USART_PrintInfo("-MAX- ");
   1170                      }
   1171                  }
   1172                  else
   1173                  {
   1174                      if(target_current < IOUT_DIVIDER_1_0) 
   1175                      {
   1176                          if(adjust_speed == PWM_SPEED_LOW)
   1177                          {
   1178                              if(PWM_GetDuty(PWM_ID_CH_CTRL) <= g_max_pwm_duty)
   1179                              {
   1180                                  PWM_DutyStepUp(PWM_ID_CH_CTRL, PWM_SPEED_L1);
   1181                              }
   1182                              else
   1183                              {
   1184                                  USART_PrintInfo("-MAX- ");
   1185                              }
   1186                          }
   1187                          else 
   1188                          {
   1189                              if(adjust_speed == PWM_SPEED_MID)
   1190                              {
   1191                                  pwm_duty = PWM_GetDuty(PWM_ID_CH_CTRL) + PWM_SPEED_L2;
   1192                              }
   1193                              else
   1194                              {
   1195                                  pwm_duty = PWM_GetDuty(PWM_ID_CH_CTRL) + PWM_SPEED_L3;
   1196                              }
   1197                          
   1198                              if(pwm_duty > g_max_pwm_duty)
   1199                              {
   1200                                  pwm_duty = g_max_pwm_duty; 
   1201                                  USART_PrintInfo("-MAX- ");
   1202                              }
   1203                              PWM_SetDuty(PWM_ID_CH_CTRL, pwm_duty, PWM_MODE_LIMIT);
   1204                          }
   1205                      }
   1206                      else
   1207                      {
   1208                          /* Get current pwm duty cycle */
   1209                          pwm_duty = PWM_GetDuty(PWM_ID_CH_CTRL);
   1210                          
   1211                          /* Calculate Next PWM duty */
   1212                          pwm_duty += adjust_speed;
   1213                          if(pwm_duty > g_max_pwm_duty)  //if(pwm_duty > PWM_DUTY_FULL)
   1214                          {
   1215                              /* Upper limit */
   1216                              pwm_duty = g_max_pwm_duty; //pwm_duty = PWM_DUTY_FULL;
   1217                              USART_PrintInfo("-MAX- ");
   1218                          }
   1219                          
   1220                          /* Set new PWM duty */
   1221                          PWM_SetDuty(PWM_ID_CH_CTRL, pwm_duty, PWM_MODE_LIMIT);
   1222                      }
   1223                  }
   1224                  break;
   1225                  
   1226              case POWER_STATE_DECREASE:
   1227                  /* Clear OVP & OCP counter */
   1228                  g_OVP_counter = 0;
   1229                  g_OCP_counter = 0;
   1230          
   1231                  /* Over Current State */
   1232                  if(g_iout_real > target_current)
   1233                  {        
   1234                      /* Calculate the difference between real value and target value */
   1235                      difference = g_iout_real - target_current;
   1236                      
   1237                      /* Select Adjust Speed for Over-Current State */
   1238                      /* Current unstable has full range speed */
   1239                      if(g_current_stable_flag != OUTPUT_STABLE)
   1240                      {
   1241                          if(difference < g_iout_threshold_low)
   1242                          {
   1243                              adjust_speed = PWM_SPEED_STEP;
   1244                              USART_PrintInfo("DOWN ");
   1245                          }
   1246                          else if(difference < g_iout_threshold_mid)
   1247                          {
   1248                              adjust_speed = PWM_SPEED_LOW;
   1249                              USART_PrintInfo("DEC_L ");
   1250                          }
   1251                          else if(difference < g_iout_threshold_high)
   1252                          {
   1253                              adjust_speed = PWM_SPEED_MID;
   1254                              USART_PrintInfo("DEC_M ");
   1255                          }
   1256                          else
   1257                          {
   1258                              adjust_speed = PWM_SPEED_HIGH;
   1259                              USART_PrintInfo("DEC_H ");
   1260                          }
   1261                      }
   1262                      /* Current enter stable condition, only have two speed */
   1263                      else
   1264                      {
   1265                          if(difference < g_iout_threshold_low)
   1266                          {
   1267                              adjust_speed = PWM_SPEED_STEP;
   1268                              USART_PrintInfo("DOWN ");
   1269                          }
   1270                          else
   1271                          {
   1272                              adjust_speed = PWM_SPEED_LOW;
   1273                              USART_PrintInfo("DEC_L ");
   1274                          }
   1275                      }
   1276                  }
   1277                  /* Over Voltage State */
   1278                  else
   1279                  {            
   1280                      /* Calculate the difference between real value and target value */
   1281                      difference = g_uout_real - g_max_voltage;
   1282                      
   1283                      /* Select Adjust Speed for Over-Voltage State */
   1284                      /* Over voltage always has full adjust speed */
   1285                      if(difference < UOUT_THRESHOLD_LOW)
   1286                      {
   1287                          adjust_speed = PWM_SPEED_STEP;
   1288                          USART_PrintInfo("DOWN ");
   1289                      }
   1290                      else if(difference < UOUT_THRESHOLD_MID)
   1291                      {
   1292                          adjust_speed = PWM_SPEED_LOW;
   1293                          USART_PrintInfo("DEC_L ");
   1294                      }
   1295                      else if(difference < UOUT_THRESHOLD_HIGH)
   1296                      {
   1297                          adjust_speed = PWM_SPEED_MID;
   1298                          USART_PrintInfo("DEC_M ");
   1299                      }
   1300                      else
   1301                      {
   1302                          adjust_speed = PWM_SPEED_HIGH;
   1303                          USART_PrintInfo("DEC_H ");
   1304                      }
   1305                  }
   1306                  
   1307                  /* Choose Adjust Mode and Update PWM Duty */
   1308                  if(adjust_speed == PWM_SPEED_STEP)
   1309                  {
   1310                      /* Step adjust mode, use step down function for fine turning */
   1311                      PWM_DutyStepDown(PWM_ID_CH_CTRL, 1); //Moon change to 0
   1312                  }
   1313                  else
   1314                  {
   1315                      if(target_current < IOUT_DIVIDER_1_0) 
   1316                      {
   1317                          if(adjust_speed == PWM_SPEED_LOW)
   1318                          {
   1319                              PWM_DutyStepDown(PWM_ID_CH_CTRL, PWM_SPEED_L1);
   1320                          }
   1321                          else 
   1322                          {
   1323                              if(adjust_speed == PWM_SPEED_MID)
   1324                              {
   1325                                  adjust_speed = PWM_SPEED_L2;
   1326                              }
   1327                              else
   1328                              {
   1329                                  adjust_speed = PWM_SPEED_L3;
   1330                              }
   1331                              pwm_duty = PWM_GetDuty(PWM_ID_CH_CTRL);
   1332                              if(pwm_duty > adjust_speed)
   1333                              {
   1334                                  pwm_duty -= adjust_speed;
   1335                              }
   1336                              else
   1337                              {
   1338                                  /* Lower limit */
   1339                                  pwm_duty = 0;
   1340                              }
   1341                              PWM_SetDuty(PWM_ID_CH_CTRL, pwm_duty, PWM_MODE_LIMIT);
   1342                          }
   1343                      }
   1344                      else
   1345                      {
   1346                          /* Get current pwm duty cycle */
   1347                          pwm_duty = PWM_GetDuty(PWM_ID_CH_CTRL);
   1348                          
   1349                          /* Calculate Next PWM duty */
   1350                          if(pwm_duty > adjust_speed)
   1351                          {
   1352                              pwm_duty -= adjust_speed;
   1353                          }
   1354                          else
   1355                          {
   1356                              /* Lower limit */
   1357                              pwm_duty = 0;
   1358                          }
   1359                          
   1360                          /* Set new PWM duty */
   1361                          PWM_SetDuty(PWM_ID_CH_CTRL, pwm_duty, PWM_MODE_LIMIT);
   1362                      }
   1363                  }
   1364                  break;
   1365          
   1366          #ifdef ENABLE_LOOP_OVP_OCP        
   1367              case POWER_STATE_OCP:
   1368                  /* Update OCP counter */
   1369                  g_OCP_counter++;
   1370                  
   1371                  /* Trigger protection function if match the trigger condition */
   1372                  if(g_OCP_counter >= OCP_OVP_TRIGGER_COUNTER)
   1373                  {
   1374                      PWM_EnterProtection();
   1375                      USART_PrintInfo("OCP_Now ");
   1376                  }
   1377                  break;
   1378                  
   1379              case POWER_STATE_OVP:
   1380                  /* Update OVP counter */
   1381                  g_OVP_counter++;
   1382                  
   1383                  /* Trigger protection function if match the trigger condition */
   1384                  if(g_OVP_counter >= OCP_OVP_TRIGGER_COUNTER)
   1385                  {
   1386                      //PWM_EnterProtection();
   1387                      USART_PrintInfo("OVP_Now ");
   1388                  }      
   1389                  break;
   1390          #endif /* ENABLE_LOOP_OVP_OCP*/
   1391          
   1392              case POWER_STATE_KEEP:
   1393              default:
   1394                  /* Clear OVP & OCP counter */
   1395                  g_OVP_counter = 0;
   1396                  g_OCP_counter = 0;
   1397                  
   1398                  /* Keep PWM duty */
   1399                  USART_PrintInfo("KEEP ");
   1400                  
   1401                  /* Output current enter stable condition */
   1402                  g_current_stable_flag = OUTPUT_STABLE;
   1403                  
   1404          #ifdef MAX_DUTY_TOLERANCE
   1405                  if(g_max_duty_enable == 0)
   1406                  {
   1407                      g_max_duty_enable = 1;
   1408                      stable_keep = 1;
   1409                      
   1410                      /* Update max pwm duty */
   1411                      g_max_pwm_duty = PWM_GetDuty(PWM_ID_CH_CTRL) + MAX_DUTY_TOLERANCE; /* max duty + tolerance */
   1412                  }
   1413          #else
   1414                  g_max_pwm_duty = 1000;
   1415          #endif
   1416                  break;
   1417              }
   1418              
   1419          #ifdef ENABLE_OVP
   1420              /*-------- OVP Hiccup Process, Add in 2016.08.25 ---------------------------*/
   1421              /* Iout very low and Uout reach max voltage means it was open/overload state */
   1422              if((g_uout_real >= (g_max_voltage -  (uint32_t)g_max_voltage * g_pwm_stable_uout / 1000)) && /* Uout reach max voltage */
   1423                 (g_iout_real <= OVP_HICCUP_IOUT) )     /* Iout very low */
   1424              {
   1425                  /* Increase counter */
   1426                  s_hiccup_counter++;
   1427                  
   1428                  /* Active OVP protection for hiccup */
   1429                  if(s_hiccup_counter >= OVP_HICCUP_COUNTER)
   1430                  {
   1431                      //PWM_EnterProtection();
   1432                  }
   1433              }
   1434              else
   1435              {
   1436                  /* Reset counter */
   1437                  s_hiccup_counter = 0;
   1438              }
   1439          #endif
   1440              
   1441          #ifdef DEBUG_PRINT
   1442              /* Test print pwm duty and current adc */
   1443              duty = PWM_GetDuty(PWM_ID_CH_CTRL);
   1444              avg_adc_iout = ADC_GetAverage(ADC_CHANNEL_IOUT);
   1445              avg_adc_uout = ADC_GetAverage(ADC_CHANNEL_UOUT);
   1446          //    sprintf((char*)tx_buff, "%4d %4d %4d %4d \n",  avg_adc_iout, avg_adc_uout, g_iout_real, g_uout_real);
   1447          //    sprintf((char*)tx_buff, "%3d.%1d %4d %4d \n",  duty/10, duty%10, avg_adc_iout, avg_adc_uout);
   1448          //    sprintf((char*)tx_buff, "%3d.%1d %4d %4d \n",  duty/10, duty%10, g_iout_real, g_uout_real);
   1449              sprintf((char*)tx_buff, "%3d.%1d \n",  duty/10, duty%10);
   1450              USART_PrintInfo(tx_buff);
   1451          #endif /* DEBUG_PRINT */
   1452          //    if(delay++>100)
   1453          //    {
   1454          //      delay=150;
   1455          //      SWT_StartTimer(SWT_ID_LOOP, 200);
   1456          //    }
   1457          //    else
   1458              {
   1459                if(target_current < IOUT_DIVIDER_1_0)
   1460                {
   1461                  SWT_StartTimer(SWT_ID_LOOP, POWER_TASK_PERIOD_LOW);
   1462                }
   1463                else
   1464                {
   1465                  SWT_StartTimer(SWT_ID_LOOP, POWER_TASK_PERIOD);
   1466                }
   1467              }
   1468              
   1469              /* Close Task */
   1470              System_CloseTask( SYS_TASK_LOOP );
   1471          }
   1472          
   1473          /*************************************************************************************************/
   1474          void Power_nfc_handle(void)
   1475          {
   1476            extern uint8_t g_nfc_tag_read;
   1477            if(System_CheckTask(SYS_TASK_NFC_HANDLE) == SYS_TASK_DISABLE)
   1478            {
   1479              return;
   1480            }
   1481            
   1482            //nfc_time_hanlde();
   1483            
   1484            AstroTimer();
                   ^
Warning[Pe223]: function "AstroTimer" declared implicitly
   1485            
   1486            if(g_nfc_tag_read==4)
   1487            SWT_StartTimer(SWT_ID_NFC_HANDLE, NFC_HANDLE_TIME);
   1488            else
   1489            SWT_StartTimer(SWT_ID_NFC_HANDLE, 5);  
   1490            
   1491            System_CloseTask( SYS_TASK_NFC_HANDLE );
   1492            
   1493          }
   1494          /**************** (C) COPYRIGHT OSRAM Asia Pacific Management Company *********END OF FILE*********/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   Power_ControlLoopTask
        40   -> ADC_CalculateAverage
        40   -> ADC_GetAverage
        40   -> PWM_DutyStepDown
        40   -> PWM_DutyStepUp
        40   -> PWM_GetDuty
        40   -> PWM_GetProtectState
        40   -> PWM_SetDuty
        40   -> Power_UpdateOne2TenDimming
        40   -> SWT_CheckTimer
        40   -> SWT_StartTimer
        40   -> System_CheckTask
        40   -> System_CloseTask
        40   -> USART_PrintInfo
        40   -> XMC_UART_CH_Transmit
        40   -> __aeabi_d2iz
        40   -> __aeabi_d2uiz
        40   -> __aeabi_dadd
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_ui2d
        40   -> abs
        40   -> sprintf
        40 __aeabi_idiv
        40 __aeabi_uidiv
       0   Power_GetAstroDimmingLevel
       0   Power_GetConstantLumenValue
       4   Power_GetControlInitDuty
       0   Power_GetCurrent
       0   Power_GetEolDimmingLevel
       0   Power_GetIoutAvgADC
       4   Power_GetMinLevel
         4 __aeabi_uidiv
      16   Power_GetOCPTriggerDuty
        16   -> __aeabi_d2iz
        16   -> __aeabi_dadd
        16   -> __aeabi_dmul
        16   -> __aeabi_ui2d
      16   Power_GetOVPTriggerDuty
        16   -> __aeabi_d2iz
        16   -> __aeabi_dadd
        16   -> __aeabi_dmul
        16   -> __aeabi_i2d
        16   -> __aeabi_ui2d
       0   Power_GetOne2TenDimming
       4   Power_GetPowerLevel
       0   Power_GetPowerLoopState
       0   Power_GetRealIout
       0   Power_GetRealUout
       0   Power_GetUoutAvgADC
       0   Power_PrepareReference
       4   Power_SetAstroDimmingLevel
       4   Power_SetConstantLumenValue
      24   Power_SetCurrent
        24   -> ADC_CalculateAverage
        24   -> ADC_GetAverage
        24   -> PWM_GetProtectState
        24   -> PWM_SetDuty
        24   -> Power_GetControlInitDuty
        24   -> Power_GetOCPTriggerDuty
        24   -> Power_GetOVPTriggerDuty
        24   -> Power_GetPowerLevel
        24   -> Power_UpdateOne2TenDimming
        24   -> __aeabi_d2iz
        24   -> __aeabi_ddiv
        24   -> __aeabi_ui2d
        24 __aeabi_idiv
        24 __aeabi_uidiv
       4   Power_SetEolDimmingLevel
       8   Power_TaskInit
         8   -> Filter_Init
         8   -> Power_SetCurrent
         8   -> SWT_StartTimer
      16   Power_UpdateOne2TenDimming
        16   -> O2T_GetEnableConfig
        16   -> O2T_GetMinDimLevel
        16   -> __aeabi_f2iz
        16   -> __aeabi_f2uiz
        16   -> __aeabi_fadd
        16   -> __aeabi_fdiv
        16   -> __aeabi_ui2f
        16   -> abs
        16 __aeabi_cfcmple
        16 __aeabi_cfrcmple
       8   Power_nfc_handle
         8   -> AstroTimer
         8   -> SWT_StartTimer
         8   -> System_CheckTask
         8   -> System_CloseTask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       8  ??DataTable3_5
       8  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable5
       8  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       8  ??DataTable8
       8  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?_0
      12  ?_1
       8  ?_10
       8  ?_11
       4  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
       8  ?_8
       8  ?_9
    2258  Power_ControlLoopTask
       6  Power_GetAstroDimmingLevel
       6  Power_GetConstantLumenValue
     124  Power_GetControlInitDuty
       6  Power_GetCurrent
       6  Power_GetEolDimmingLevel
       6  Power_GetIoutAvgADC
      50  Power_GetMinLevel
      68  Power_GetOCPTriggerDuty
      66  Power_GetOVPTriggerDuty
       6  Power_GetOne2TenDimming
     176  Power_GetPowerLevel
       6  Power_GetPowerLoopState
       6  Power_GetRealIout
       6  Power_GetRealUout
       6  Power_GetUoutAvgADC
       2  Power_PrepareReference
      50  Power_SetAstroDimmingLevel
      50  Power_SetConstantLumenValue
     510  Power_SetCurrent
      50  Power_SetEolDimmingLevel
      44  Power_TaskInit
     356  Power_UpdateOne2TenDimming
      52  Power_nfc_handle
       1  delay
       4  dim_level_1_10
       1  g_OCP_counter
       1  g_OVP_counter
       4  g_a_period
       2  g_astro_dimming_level
       2  g_constant_lumen
       1  g_control_loop_state
       2  g_current_a
       1  g_current_stable_flag
       2  g_eol_dimming_level
       2  g_iout_avg_adc
       2  g_iout_real
       2  g_iout_threshold_high
       2  g_iout_threshold_low
       2  g_iout_threshold_mid
       1  g_max_duty_enable
       2  g_max_pwm_duty
       2  g_max_voltage
       2  g_min_current
       2  g_one2ten_avg_adc
       2  g_one2ten_dimming_level
       4  g_power_current
       4  g_power_current_pre
       2  g_pwm_stable_iout
       2  g_pwm_stable_uout
       4  g_s_period
       2  g_target_current
       2  g_test_current
       2  g_uout_avg_adc
       2  g_uout_real
       4  i_out_roll
       1  s_flag_off
       1  s_hiccup_counter
       4  s_min_level
       1  s_one_ten_update
       4  temp1
       4  temp1
       4  temp2
       4  temp2
       4  temp3
       4  temp4
       4  u_out_roll

 
    84 bytes in section .bss
    21 bytes in section .data
    96 bytes in section .rodata
 4 244 bytes in section .text
 
 4 244 bytes of CODE  memory
    96 bytes of CONST memory
   105 bytes of DATA  memory

Errors: none
Warnings: 13
