###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       10/Apr/2019  11:23:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\XMC_Peripheral_Library\XMCLib\src\xmc_spi.c
#    Command line =  
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\XMC_Peripheral_Library\XMCLib\src\xmc_spi.c"
#        -D XMC1301_T038x0064 -D OT_NFC_IP67_200W -D NDEBUG -D ENABLT_WDT -D
#        ENABLE_COMM -D ENABLE_USART -D nDEBUG_PRINT -D nDEBUG_VERSION -D
#        MODULE_I2C -D MODULE_M24LRxx -D MODULE_NFC -D MODULE_NFC_DALI -D
#        ENASTRO -D NO_FAST_TIME_ASTRO -D NO_EN_CLM_TIME_FAST -D ENABLE_OVP -D
#        ENABLE_MOBILE -D ENABLE_ONE2TEN -D BYTEORDER_LITTLE_ENDIAN -D
#        AVAILABLE_PORTS_NUMBER=3 -D FW_HIGH=01 -D FW_LOW=02 -D ENASTRO -D
#        MPC_O2T_DEFAULT_SETTINGS -D MPC_O2T_DEFAULT_BOUNDARIES -lc "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List" -o "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\IAR ARM
#        7.8\arm\INC\c\DLib_Config_Normal.h" -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\inc\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Driver\inc\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\devices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\driver_ot\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\fileTank\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\M24LRxx\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\"
#        -I PROJ_DIR$\..\Application\src\modules\NVM\api\ -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_xmc1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\currentset\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\DaliServices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\HW\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Modules\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Optional\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Services\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Acl\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\Legacy\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Clm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Csm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Info\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSK\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\O2T\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\AstroDim\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSKEncryption\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Power\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\EOL\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NFC\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\I2C\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC16\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\hwdrivers\XMC1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -Ol
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List\xmc_spi.lst
#    Object file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj\xmc_spi.o
#
###############################################################################

C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\XMC_Peripheral_Library\XMCLib\src\xmc_spi.c
      1          /**
      2           * @file xmc_spi.c
      3           * @date 2015-11-04
      4           *
      5           * @cond
      6           *********************************************************************************************************************
      7           * XMClib v2.1.6 - XMC Peripheral Driver Library 
      8           *
      9           * Copyright (c) 2015-2016, Infineon Technologies AG
     10           * All rights reserved.                        
     11           *                                             
     12           * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the 
     13           * following conditions are met:   
     14           *                                                                              
     15           * Redistributions of source code must retain the above copyright notice, this list of conditions and the following 
     16           * disclaimer.                        
     17           * 
     18           * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following 
     19           * disclaimer in the documentation and/or other materials provided with the distribution.                       
     20           * 
     21           * Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote 
     22           * products derived from this software without specific prior written permission.                                           
     23           *                                                                              
     24           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
     25           * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  
     26           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     27           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  
     28           * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
     29           * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     30           * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                                  
     31           *                                                                              
     32           * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes with 
     33           * Infineon Technologies AG dave@infineon.com).                                                          
     34           *********************************************************************************************************************
     35           *
     36           * Change History
     37           * --------------
     38           *
     39           * 2015-02-20:
     40           *     - Initial <br>
     41           *      
     42           * 2015-05-20:
     43           *     - Modified XMC_SPI_CH_Stop() API for not setting to IDLE the channel if it is busy
     44           *     - Modified XMC_SPI_CH_SetInterwordDelay() implementation in order to gain accuracy <br>
     45           *     
     46           * 2015-06-20:
     47           *     - Removed GetDriverVersion API <br>
     48           *
     49           * 2015-09-01:
     50           *     - Modified XMC_SPI_CH_EnableEvent() and XMC_SPI_CH_DisableEvent() for supporting multiple events configuration <br>
     51           *
     52           * 2015-11-04: 
     53           *     - Modified the check of XMC_USIC_CH_GetTransmitBufferStatus() in the XMC_SPI_CH_Transmit() flag <br>
     54           * @endcond 
     55           *
     56           */
     57          /**
     58           *
     59           * @brief SPI driver for XMC microcontroller family
     60           *
     61           */
     62          /*********************************************************************************************************************
     63           * HEADER FILES
     64           ********************************************************************************************************************/
     65          
     66          #include <xmc_scu.h>
     67          #include <xmc_spi.h>
     68          
     69          /*********************************************************************************************************************
     70           * MACROS
     71           ********************************************************************************************************************/
     72          #define XMC_SPI_CH_OVERSAMPLING (2UL)
     73          
     74          /*********************************************************************************************************************
     75           * API IMPLEMENTATION
     76           ********************************************************************************************************************/
     77           
     78          /* Initializes the selected SPI channel with the config structure. */
     79          void XMC_SPI_CH_Init(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_CONFIG_t *const config)
     80          {
     81            XMC_USIC_CH_Enable(channel);
     82            
     83            if(config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER)
     84            {
     85              /* Configure baud rate */
     86              (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, XMC_SPI_CH_OVERSAMPLING); 
     87            }
     88            
     89            /* Configuration of USIC Shift Control */
     90            /* Transmission Mode (TRM) = 1  */
     91            /* Passive Data Level (PDL) = 1 */
     92            channel->SCTR = USIC_CH_SCTR_PDL_Msk |
     93                            (0x1UL << USIC_CH_SCTR_TRM_Pos) |
     94                            (0x3fUL << USIC_CH_SCTR_FLE_Pos)|
     95                            (0x7UL << USIC_CH_SCTR_WLE_Pos);
     96          
     97            /* Configuration of USIC Transmit Control/Status Register */
     98            /* TBUF Data Enable (TDEN) = 1 */
     99            /* TBUF Data Single Shot Mode (TDSSM) = 1 */
    100            channel->TCSR = (uint32_t)(USIC_CH_TCSR_HPCMD_Msk |
    101                            (0x01UL  << USIC_CH_TCSR_TDEN_Pos) |
    102                            USIC_CH_TCSR_TDSSM_Msk);
    103          
    104            if(config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER)
    105            {
    106              /* Configuration of Protocol Control Register */
    107              channel->PCR_SSCMode = (uint32_t)(USIC_CH_PCR_SSCMode_MSLSEN_Msk |
    108                                     USIC_CH_PCR_SSCMode_SELCTR_Msk |
    109                                     (uint32_t)config->selo_inversion |
    110                                     USIC_CH_PCR_SSCMode_FEM_Msk);
    111            }
    112          
    113            /* Clear protocol status */
    114            channel->PSCR = 0xFFFFFFFFUL;
    115          
    116            /* Set parity settings */
    117            channel->CCR = (uint32_t)config->parity_mode;
    118          }
    119          
    120          XMC_SPI_CH_STATUS_t XMC_SPI_CH_SetBaudrate(XMC_USIC_CH_t *const channel, const uint32_t rate)
    121          {
    122            XMC_SPI_CH_STATUS_t status;
    123            
    124            status = XMC_SPI_CH_STATUS_ERROR;
    125            
    126            if (rate <= (XMC_SCU_CLOCK_GetPeripheralClockFrequency() >> 1U))
    127            {
    128              if (XMC_USIC_CH_SetBaudrate(channel, rate, XMC_SPI_CH_OVERSAMPLING) == XMC_USIC_CH_STATUS_OK)
    129              {
    130                status = XMC_SPI_CH_STATUS_OK;
    131              }
    132            } 
    133            return status;
    134          }
    135          
    136          /* Enable the selected slave signal by setting (SELO) bits in PCR register. */
    137          void XMC_SPI_CH_EnableSlaveSelect(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_SLAVE_SELECT_t slave)
    138          {
    139            /* Configuration of Protocol Control Register */
    140            channel->PCR_SSCMode &= (uint32_t)~USIC_CH_PCR_SSCMode_SELO_Msk;
    141            channel->PCR_SSCMode |= (uint32_t)slave;
    142          }
    143          
    144          /* Disable the slave signals by clearing (SELO) bits in PCR register. */
    145          void XMC_SPI_CH_DisableSlaveSelect(XMC_USIC_CH_t *const channel)
    146          {
    147            XMC_SPI_CH_ClearStatusFlag(channel, (uint32_t)XMC_SPI_CH_STATUS_FLAG_MSLS);
    148            
    149            /* Configuration of Protocol Control Register */
    150            channel->PCR_SSCMode &= (uint32_t)~USIC_CH_PCR_SSCMode_SELO_Msk;
    151          }
    152          
    153          /* Puts the data into FIFO if FIFO mode is enabled or else into standard buffers, by setting the proper mode. */
    154          void XMC_SPI_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data, const XMC_SPI_CH_MODE_t mode)
    155          {
    156          
    157            channel->CCR = (channel->CCR & (uint32_t)(~USIC_CH_CCR_HPCEN_Msk)) |
    158                           (((uint32_t) mode << USIC_CH_CCR_HPCEN_Pos) & (uint32_t)USIC_CH_CCR_HPCEN_Msk);
    159          
    160          
    161            /* Check FIFO size */
    162            if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
    163            {
    164              while((uint32_t)XMC_USIC_CH_GetTransmitBufferStatus(channel) == (uint32_t)XMC_USIC_CH_TBUF_STATUS_BUSY)
    165              {
    166              }
    167            
    168              XMC_SPI_CH_ClearStatusFlag(channel, (uint32_t)XMC_SPI_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
    169            
    170              channel->TBUF[mode] = data;
    171            }
    172            else
    173            {
    174              channel->IN[mode] = data;
    175            }
    176          }
    177          
    178          /* Reads the data from the buffers based on the FIFO mode selection. */
    179          uint16_t XMC_SPI_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
    180          {
    181            uint16_t retval;
    182          
    183            /* Check FIFO size */
    184            if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
    185            {
    186              retval = (uint16_t)channel->RBUF;
    187            }
    188            else
    189            {
    190              retval = (uint16_t)channel->OUTR;
    191            }
    192          
    193            return retval;
    194          }
    195          
    196          /* Configures the inter word delay by setting PCR.PCTQ1, PCR.DCTQ1 bit fields. */
    197          void XMC_SPI_CH_SetInterwordDelay(XMC_USIC_CH_t *const channel,uint32_t tinterword_delay_us)
    198          {
    199            uint32_t peripheral_clock;
    200            uint32_t pdiv;
    201            uint32_t step;
    202            uint32_t fFD;
    203            uint32_t fpdiv;
    204            uint32_t divider_factor1 = 0U;
    205            uint32_t divider_factor2 = 32U;
    206            uint32_t divider_factor1_int = 0U;
    207            uint32_t divider_factor1_int_min = 4U;
    208            uint32_t divider_factor1_frac_min =100U;
    209            uint32_t divider_factor1_frac = 0U;
    210            uint32_t divider_factor2_temp = 0U;
    211            peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
    212            pdiv = (uint32_t)(channel->BRG & USIC_CH_BRG_PDIV_Msk) >> USIC_CH_BRG_PDIV_Pos;
    213            step = (uint32_t)(channel->FDR & USIC_CH_FDR_STEP_Msk) >> USIC_CH_FDR_STEP_Pos;
    214            fFD = (uint32_t)((peripheral_clock >> 10U) * step);
    215            fpdiv= fFD/(1U+pdiv);
    216          
    217            if(tinterword_delay_us < (128000000/fpdiv))
    218            {
    219              for(divider_factor2_temp = 32U; divider_factor2_temp > 0U; --divider_factor2_temp)
    220              {
    221          
    222                divider_factor1 = (tinterword_delay_us*fpdiv)/(divider_factor2_temp*10000);
    223                divider_factor1_frac = divider_factor1%100U;
    224          
    225                if(divider_factor1_frac > 50)
    226                {
    227                  divider_factor1_int =  (divider_factor1/100U)+1;
    228                  divider_factor1_frac = (divider_factor1_int*100)-divider_factor1;
    229                }
    230                else
    231                {
    232                  divider_factor1_int =  (divider_factor1/100U);
    233                }
    234          
    235                if ((divider_factor1_int < 5U) && (divider_factor1_int > 0) && (divider_factor1_frac < divider_factor1_frac_min))
    236                {
    237                  divider_factor1_frac_min = divider_factor1_frac;
    238                  divider_factor1_int_min = divider_factor1_int;
    239                  divider_factor2= divider_factor2_temp;
    240                }
    241              }
    242            }
    243          
    244            channel->PCR_SSCMode = (uint32_t)((channel->PCR_SSCMode) & (~(USIC_CH_PCR_SSCMode_DCTQ1_Msk |
    245                                                                          USIC_CH_PCR_SSCMode_PCTQ1_Msk |
    246                                                                          USIC_CH_PCR_SSCMode_CTQSEL1_Msk))) |
    247                                   (((divider_factor1_int_min - 1) << USIC_CH_PCR_SSCMode_PCTQ1_Pos) & (uint32_t)USIC_CH_PCR_SSCMode_PCTQ1_Msk) |
    248                                   (((divider_factor2 - 1 ) << USIC_CH_PCR_SSCMode_DCTQ1_Pos) & (uint32_t)USIC_CH_PCR_SSCMode_DCTQ1_Msk);
    249          }
    250          
    251          XMC_SPI_CH_STATUS_t XMC_SPI_CH_Stop(XMC_USIC_CH_t *const channel)
    252          {
    253            XMC_SPI_CH_STATUS_t status = XMC_SPI_CH_STATUS_OK;
    254          
    255            if (((uint32_t)XMC_USIC_CH_GetTransmitBufferStatus(channel) & (uint32_t)XMC_USIC_CH_TBUF_STATUS_BUSY) != 0U)
    256            {
    257              status = XMC_SPI_CH_STATUS_BUSY;
    258            }
    259            else
    260            {
    261          
    262              /* USIC channel in IDLE mode */
    263              XMC_USIC_CH_SetMode(channel, XMC_USIC_CH_OPERATING_MODE_IDLE);
    264            }
    265          
    266            return status;
    267          }
    268          
    269          void XMC_SPI_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
    270          {
    271            channel->CCR |= (event&0x1fc00U);
    272            channel->PCR_SSCMode |= ((event << 13U) & 0xe000U);
    273          }
    274          
    275          void XMC_SPI_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
    276          {
    277            channel->CCR &= (uint32_t)~(event&0x1fc00U);
    278            channel->PCR_SSCMode &= (uint32_t)~((event << 13U) & 0xe000U);
    279          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   XMC_SPI_CH_ClearStatusFlag
       0   XMC_SPI_CH_DisableEvent
       8   XMC_SPI_CH_DisableSlaveSelect
         8   -> XMC_SPI_CH_ClearStatusFlag
       0   XMC_SPI_CH_EnableEvent
       0   XMC_SPI_CH_EnableSlaveSelect
       4   XMC_SPI_CH_GetReceivedData
      16   XMC_SPI_CH_Init
        16   -> XMC_USIC_CH_Enable
        16   -> XMC_USIC_CH_SetBaudrate
      16   XMC_SPI_CH_SetBaudrate
        16   -> XMC_SCU_CLOCK_GetPeripheralClockFrequency
        16   -> XMC_USIC_CH_SetBaudrate
      40   XMC_SPI_CH_SetInterwordDelay
        40   -> XMC_SCU_CLOCK_GetPeripheralClockFrequency
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      16   XMC_SPI_CH_Stop
        16   -> XMC_USIC_CH_GetTransmitBufferStatus
        16   -> XMC_USIC_CH_SetMode
      16   XMC_SPI_CH_Transmit
        16   -> XMC_SPI_CH_ClearStatusFlag
        16   -> XMC_USIC_CH_GetTransmitBufferStatus
       0   XMC_USIC_CH_GetTransmitBufferStatus
       0   XMC_USIC_CH_SetMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       8  XMC_SPI_CH_ClearStatusFlag
      28  XMC_SPI_CH_DisableEvent
      22  XMC_SPI_CH_DisableSlaveSelect
      28  XMC_SPI_CH_EnableEvent
      16  XMC_SPI_CH_EnableSlaveSelect
      32  XMC_SPI_CH_GetReceivedData
      66  XMC_SPI_CH_Init
      40  XMC_SPI_CH_SetBaudrate
     196  XMC_SPI_CH_SetInterwordDelay
      34  XMC_SPI_CH_Stop
      96  XMC_SPI_CH_Transmit
       8  XMC_USIC_CH_GetTransmitBufferStatus
      14  XMC_USIC_CH_SetMode

 
 608 bytes in section .text
 
 608 bytes of CODE memory

Errors: none
Warnings: none
