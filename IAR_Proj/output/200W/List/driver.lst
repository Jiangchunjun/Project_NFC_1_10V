###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       16/Apr/2019  11:20:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\driver.c
#    Command line =  
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\driver.c" -D
#        XMC1301_T038x0064 -D OT_NFC_IP67_200W -D NDEBUG -D ENABLT_WDT -D
#        ENABLE_COMM -D ENABLE_USART -D nDEBUG_PRINT -D nDEBUG_VERSION -D
#        MODULE_I2C -D MODULE_M24LRxx -D MODULE_NFC -D MODULE_NFC_DALI -D
#        ENASTRO -D NO_FAST_TIME_ASTRO -D NO_EN_CLM_TIME_FAST -D ENABLE_OVP -D
#        ENABLE_MOBILE -D ENABLE_ONE2TEN -D BYTEORDER_LITTLE_ENDIAN -D
#        AVAILABLE_PORTS_NUMBER=3 -D FW_HIGH=01 -D FW_LOW=02 -D ENASTRO -D
#        MPC_O2T_DEFAULT_SETTINGS -D MPC_O2T_DEFAULT_BOUNDARIES -lc "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List" -o "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\IAR ARM
#        7.8\arm\INC\c\DLib_Config_Normal.h" -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\inc\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Driver\inc\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\devices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\driver_ot\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\fileTank\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\M24LRxx\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\"
#        -I PROJ_DIR$\..\Application\src\modules\NVM\api\ -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_xmc1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\currentset\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\DaliServices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\HW\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Modules\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Optional\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Services\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Acl\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\Legacy\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Clm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Csm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Info\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSK\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\O2T\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\AstroDim\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSKEncryption\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Power\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\EOL\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NFC\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\I2C\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC16\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\hwdrivers\XMC1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -Ol
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List\driver.lst
#    Object file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj\driver.o
#
###############################################################################

C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\driver.c
      1          // ---------------------------------------------------------------------------------------------------------------------
      2          // Firmware for OutDoor 2Dim project 
      3          // ---------------------------------------------------------------------------------------------------------------------
      4          // (c) Osram GmbH
      5          
      6          //
      7          // The content of this file is intellectual property of OSRAM GmbH. It is
      8          // confidential and not intended for any public release. All rights reserved.
      9          //
     10          //
     11          // Indent style: Replace tabs by spaces, 2 spaces per indentation level
     12          //
     13          // Initial version:  2019-03-17
     14          // $Author: Moon Jiang $
     15          // $Revision: 00 $
     16          // $Date: 2016-04 25 16:19:38 +0100 (gio, 11 feb 2016) $
     17          // $Id: driver.c 2911 2016-04-25 15:19:38Z Moon Jiang $
     18          /*******************************************************************************************************************//**
     19          * @file
     20          * @brief Handle RF request from RF and generate PWM singal to control OT
     21          ***********************************************************************************************************************/
     22          
     23          /*******************************************************************************************************************//**
     24          * @defgroup HW HW - Hardware drivers and hardware dependent parameters
     25          * @{
     26          ***********************************************************************************************************************/
     27          
     28          #ifdef MODULE_NFC
     29          
     30          #include "driver.h"

  #warning ::::::::::::::::::::::::::: Using original LEDset resistor (wrong for MP) :::::::::::::::::::::::::::
   ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",86  Warning[Pe1105]: 
          #warning directive: ::::::::::::::::::::::::::: Using original LEDset
          resistor (wrong for MP) :::::::::::::::::::::::::::

  #warning ::::::::::::::::::::::::::: Using original LEDset resistor (wrong for MP) :::::::::::::::::::::::::::
   ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",86  Warning[Pe1105]: 
          #warning directive: ::::::::::::::::::::::::::: Using original LEDset
          resistor (wrong for MP) :::::::::::::::::::::::::::

  #define LEDSET_M                                            (32913)
          ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",92  Warning[Pe047]: 
          incompatible redefinition of macro "LEDSET_M" (declared at line 92)

  #define LEDSET_Q                                            (1900065)
          ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",93  Warning[Pe047]: 
          incompatible redefinition of macro "LEDSET_Q" (declared at line 93)

  #define LEDSET_RESISTOR_SUM_OHM                             (3030.0)
          ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\inc\power_config_200w.h",95  Warning[Pe047]: 
          incompatible redefinition of macro "LEDSET_RESISTOR_SUM_OHM"
          (declared at line 95)

    #warning "ATTENTION! A standard default value of I2C Cyclic calling period\
     ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\modules\I2C\i2c_userinterface.h",82  Warning[Pe1105]: 
          #warning directive: "ATTENTION! A standard default value of I2C
          Cyclic calling period I2C_RUNTIME_TIMER_PERIOD_US is going to be
          used! A custom value, specific for each application is recommended
          and has to be placed inside ConfigI2c.h"

    #warning "ATTENTION! A standard default value of I2C Cyclic calling period\
     ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\modules\I2C\i2c_userinterface.h",92  Warning[Pe1105]: 
          #warning directive: "ATTENTION! A standard default value of I2C
          Cyclic calling period I2C_SLEEPMODE_TIMER_PERIOD_US is going to be
          used! A custom value, specific for each application is recommended
          and has to be placed inside ConfigI2c.h"

    #warning "ATTENTION! A standard default value of I2C Cyclic calling period\
     ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\modules\I2C\i2c_userinterface.h",102  Warning[Pe1105]: 
          #warning directive: "ATTENTION! A standard default value of I2C
          Cyclic calling period I2C_POWERDOWN_TIMER_PERIOD_US is going to be
          used! A custom value, specific for each application is recommended
          and has to be placed inside ConfigI2c.h"
     31          #include "xmc_flash.h"
     32          #include "i2c_local.h"
     33          
     34          
     35          
     36          uint8_t  g_moble_flag           = 0;
     37          uint8_t  g_nfc_current_set      = 0;
     38          uint8_t  g_nfc_update_flag      = 0;
     39          uint8_t  g_pwm_update_flag      = 1;
     40          //uint8_t  g_nfc_start_flag       = 0;
     41          uint8_t  g_psw_update_flag      = 0;
     42          uint32_t g_nfc_time             = 0; //nfc running time
     43          uint32_t g_nfc_fast_save_time   = 0; //nfc saving time 
     44          uint32_t g_ed_time              = 0;
     45          uint32_t g_last_ontime          =0;
     46          uint8_t  g_nfc_time_id          = 0;
     47          uint8_t  g_nfc_flag_record      = 0;
     48          uint8_t  g_nfc_flag_pwm         = 0;
     49          uint8_t  g_nfc_dim_percent      = 100;
     50          uint8_t  g_nfc_current_percent  = 50;
     51          uint8_t  g_astro_flag=0;//flag for Astros start purpose
     52          uint8_t  g_inf_time_update=0;
     53          uint8_t  g_flag_flash_write=0;
     54          uint8_t  flag_t4t_update=0;
     55          uint32_t g_time_nvm_pre=0,time_save=0;
     56          uint16_t g_min_dim_level=0;
     57          uint8_t last_dim_level=4;
     58          const uint8_t g_gtin_num[6]=GTIN_NUM; 
     59          uint8_t g_nfc_flag_save=0;
     60          
     61          
     62          typedef struct
     63          {
     64          	uint8_t  mode ;
     65            	int16_t  duration[8];
     66          	uint16_t  level[8];
     67          	uint16_t  fade[8];
     68          
     69          	int32_t  stepcounter[8];
     70          	uint32_t  ontimeED;
     71          	uint16_t  presentLevel ;
     72          
     73          }
     74          typeAstro_t;
     75          typeAstro_t  dimmer;
     76          
     77          uint8_t dimEnable;
     78          uint8_t dimStep;
     79          uint8_t dimFlag;
     80          bool dimOverride;
     81          
     82          
     83          
     84          /****************************************************************
     85          * @Brief   nfc_time_record
     86          record the driver run time in the nfc tag MCU using part
     87          update g_timer in very 30s. Total 16 blocks are using.
     88          every 16*30 s update time in the nfc_bank stucture.
     89          16 blocks are running in cycle.
     90          * @Note    
     91          * @Return  
     92          *******************************************************************************/
     93          void nfc_time_record(void)
     94          {
     95              static uint8_t  g_nfc_flag_record=0; //set time period
     96              
     97              //g_nfc_time=InfoMPC_GetLampOnMinutes(0)*60; //get running time
     98              
     99              if(g_nfc_time-g_nfc_fast_save_time>179&&g_nfc_flag_record==0)//every 3 minute. total 3*24 72min
    100              {
    101                g_nfc_flag_record=1;
    102                
    103                g_nfc_fast_save_time=g_nfc_time;
    104              }
    105              
    106              if(g_nfc_time-time_save>3600)//one hour time to save data
    107                
    108              {
    109                g_nfc_flag_save=g_nfc_flag_save;
    110                
    111                time_save=g_nfc_time;
    112              }
    113              
    114              if(g_nfc_flag_record) // 60s flag check
    115              { 
    116                
    117                if((I2cAreAllPendingTransfersDone()==1)&&nfc_local_state.fsm_state==nfc_fsm_state_idle) //no nfc mirror task
    118                {
    119                  
    120                  if(I2cWrite(NFC_TIME_ADRRESS+g_nfc_time_id*4, (uint8_t *)&g_nfc_time,4)==true)
    121                    
    122                  {
    123                    
    124                    g_nfc_flag_record=0;  //close 60s flag
    125                    
    126                    if(g_nfc_time_id++>=23)// block++;if it is up to number 47 , need to set to num 0
    127                    {
    128                      
    129                      g_nfc_time_id=0;  //set block num to 0
    130                      
    131                      //s_time=g_nfc_time/60; // g_time set from second to minute.
    132                      
    133                      
    134                      //g_nfc_update_flag=1;  //set flag to store time in backup area  // need to save the time information
    135                      
    136                    }
    137                  }
    138                }   
    139              }
    140              
    141          }
    142          /*******************************************************************************
    143          * @Brief   nfc_time_id
    144          read total 16 array time data, and set g_nfc_time with maximum data. 
    145          and return time record current index id.
    146          * @Param   null
    147          * @Note    
    148          * @Return  time record id
    149          *******************************************************************************/
    150          uint8_t nfc_time_id(void)
    151          {
    152              static uint8_t s_arr[NFC_TIME_COUNT], id_index=0;
    153              uint32_t s_arr_time[(NFC_TIME_COUNT>>2)];
    154              uint8_t i=0,j=0;
    155              static uint8_t index_flag=0, time_id_flag=0,read_flag=0;
    156              extern i2c_local_state_t        i2c_local_state;
    157              
    158              if(time_id_flag==0)
    159              {
    160                
    161              nfc_local_state.fast_timer_cnt = 0;
    162              
    163              switch (index_flag)
    164              {
    165                
    166              case 0:
    167                
    168                //index_flag=1; //read_data first
    169                
    170                
    171                if(read_flag==0)
    172                {
    173                  if(I2cRead(NFC_TIME_ADRRESS+4*id_index,&s_arr[0+4*id_index],4)==1)//read first 60 byte time data //all the time data
    174                  {
    175                    read_flag=1;
    176                  } 
    177                }
    178                else
    179                {
    180                  if(read_flag==1)
    181                  {
    182                    if(i2c_local_state.rx_request.is_filled ==false)// read judge is_filled.
    183                    {        
    184                      //I2cCyclic();
    185                      id_index++;
    186                      read_flag=0;
    187                      //nfc_local_state.fast_timer_cnt = 0;
    188                    }
    189                    
    190                  }
    191                }
    192                  
    193                  if(id_index>23)
    194                  {
    195                    id_index=0;
    196                    index_flag=1; //read_data first
    197                    //time_id_flag=1;
    198                  }
    199          
    200                
    201                break;
    202                
    203                
    204              case 1:
    205                
    206                for(i=0;i<NFC_TIME_COUNT;i+=4)//need to take care of read result
    207                {
    208                  
    209                  s_arr_time[j++]=(s_arr[i]<<0)+(s_arr[i+1]<<8)+(s_arr[i+2]<<16)+(s_arr[i+3]<<24);
    210                  /* get all 16 record time in s_arr_time*/
    211                  if(s_arr_time[(j-1)]==0XFFFFFFFF)
    212                  {
    213                    /*if value is FFFFFFFF then set it to zero*/
    214                    s_arr_time[j-1]=0;
    215                  }
    216                }
    217                
    218                j=0;
    219                
    220                for(i=1;i<(NFC_TIME_COUNT>>2);i++)
    221                {
    222                  if(s_arr_time[0]<s_arr_time[i])
    223                  {
    224                    
    225                    s_arr_time[0]=s_arr_time[i];// get the max time data
    226                    
    227                    j=i;
    228                    
    229                  }
    230                }
    231                
    232                g_nfc_time=s_arr_time[0]; 
    233                
    234                if(abs(g_nfc_time-InfoMPC_GetLampOnMinutes(0)*60)<3600)
                          ^
Warning[Pe223]: function "abs" declared implicitly

        if(abs(g_nfc_time-InfoMPC_GetLampOnMinutes(0)*60)<3600)
                          ^
"C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\driver.c",234  Warning[Pe223]: 
          function "InfoMPC_GetLampOnMinutes" declared implicitly
    235                {
    236                    MemoryBank_Info_SetMinute_value(g_nfc_time/60);
                           ^
Warning[Pe223]: function "MemoryBank_Info_SetMinute_value" declared implicitly
    237                }
    238                else
    239                {
    240                  g_nfc_time=InfoMPC_GetLampOnMinutes(0)*60;
    241                }
    242                /*set g_nfc_time with max record time*/
    243                
    244                time_id_flag=1;
    245                
    246                g_nfc_time_id=j;
    247                
    248                time_save=g_nfc_time;// set time_save when on time saving every one hour
    249                
    250                g_nfc_fast_save_time=g_nfc_time;//fast time saving every 2min
    251              
    252              //return j;  // return maximum time record index id.
    253              
    254              break;
    255              
    256              }
    257              
    258              return time_id_flag;
    259              }
    260          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "nfc_time_id"
    261          /*******************************************************************************
    262          * @Brief   nfc_ed_record
    263          calculate ed time and record ed time.
    264          * @Param   
    265          * @Note    
    266          * @Return  ed time
    267          *******************************************************************************/
    268          bool nfc_ed_record(void)
    269          {
    270            static uint8_t ed_index, ed_count,i,index_read=0;
    271            static uint8_t test_data[24],index_flag=0,read_flag=0;
    272            static bool ed_read=0,update_flag=0;
    273            static uint32_t runtime_pre;
    274            uint32_t ed_time;
    275            extern i2c_local_state_t        i2c_local_state;
    276            
    277            
    278            if(ed_read==0)
    279            {
    280              
    281            //nfc_local_state.fast_timer_cnt = 0;
    282              
    283            switch (index_flag)   
    284            {
    285              
    286            case 0:
    287              
    288               nfc_local_state.fast_timer_cnt=0; // reset slow timer count
    289               
    290              if(read_flag==0)
    291              {
    292                if (I2cRead(NFC_ED_TIME_ADRESS+4*index_read,&test_data[index_read*4],4)==1)
    293                {
    294                  read_flag=1;
    295                }
    296              }
    297              
    298              if(read_flag==1)
    299              {
    300                
    301                if(i2c_local_state.rx_request.is_filled ==false)// read judge is_filled.
    302                {        
    303                  I2cCyclic(); 
    304                  
    305                  index_read++;
    306                  
    307                  read_flag=0;
    308                  //nfc_local_state.fast_timer_cnt = 0;
    309                }
    310                
    311                if(index_read>5)
    312                index_flag=1; //read_data first
    313              }
    314              break; 
    315              
    316            case 1:
    317              
    318              {
    319                  /*read ed index*/
    320                  
    321                  ed_index=test_data[0];
    322                  
    323                  if(ed_index==0XFF)
    324                  {
    325                    /*ed_index value is wrong value*/
    326                    ed_index=0X00;
    327                  }
    328                  /*ed index maximum is 7 then set to num 0*/
    329                  if(ed_index>8)
    330                    ed_index=0;
    331          
    332                  ed_count= test_data[1];
    333                  
    334                  if(MemoryBank_Astro_GetStartEDontime(0)==0)// reset ed time
                            ^
Warning[Pe223]: function "MemoryBank_Astro_GetStartEDontime" declared
          implicitly
    335                    
    336                  {
    337                    ed_index=0;
    338                    test_data[0]=0;
    339                    
    340                    ed_count=0;
    341                    test_data[1]=0;         
    342                  }
    343                /*read ed record count*/        
    344                  if(ed_count==0XFF)
    345                  {
    346                    /*ed_count value is wrong value*/
    347                    ed_count=0X00;
    348                  }
    349                  if(ed_count>=8)
    350                    ed_count=8;
    351                  /*ed record count max is 8*/
    352                  
    353                  /*get last start up time*/
    354                  runtime_pre=((test_data[4]<<0)+(test_data[5]<<8)+(test_data[6]<<16)+(test_data[7]<<24));
    355                  if(runtime_pre==0XFFFFFFFF)
    356                  {
    357                    /*runtime_pre value is wrong value*/
    358                    runtime_pre=0X00;
    359                  }
    360                  index_flag=2;// read data is done
    361                  
    362                  break;
    363              }
    364                  
    365              case 2:
    366                {
    367                  g_last_ontime=runtime_pre;
    368                  
    369                  if(g_nfc_time>runtime_pre)   
    370                  {
    371                    ed_time=g_nfc_time-runtime_pre; 
    372                    /*ed_time is equal last turn off time minus last start up time*/
    373                  }
    374                  else
    375                  {
    376                    ed_time=0;  
    377                  }
    378                  ed_time/=60;// sencond to minute
    379                  
    380                  if(ONTIME_MIN_VALUE_MINUTES<=ed_time&&ed_time<=ONTIME_MAX_VALUE_MINUTES)//ed time is in right range
    381                  {
    382                              
    383                    test_data[8+ed_index*2]=(uint8_t)(ed_time>>8);
    384                    
    385                    test_data[8+ed_index*2+1]=(uint8_t)(ed_time);
    386                    
    387                    if(ed_index++>=7)//record 8 times need to recycle
    388                    {
    389                      ed_index=0;
    390                    }
    391                    test_data[0]=ed_index;
    392                    
    393                    if(ed_count<8)
    394                    {
    395                      ed_count++;  //count max value is 8            
    396                    }
    397                    
    398                    test_data[1]=ed_count;
    399                    
    400                    update_flag=1;
    401           
    402                    
    403                  }
    404                  
    405                  test_data[4]=(uint8_t)(g_nfc_time);//save new on time
    406                  
    407                  test_data[5]=(uint8_t)(g_nfc_time>>8);//save new on time
    408                  
    409                  test_data[6]=(uint8_t)(g_nfc_time>>16);//save new on time
    410                  
    411                  test_data[7]=(uint8_t)(g_nfc_time>>24);//save new on time
    412                  
    413                  g_last_ontime=g_nfc_time;//record start up time
    414                  
    415                  runtime_pre=g_nfc_time;
    416                  
    417                  if(ed_count>=1)
    418                  {
    419                    for(i=0;i<ed_count;i++)
    420                    {
    421                      g_ed_time+=(test_data[8+2*i]<<8);
    422                      g_ed_time+=(test_data[8+2*i+1]);//get all recorded g_ed_time
    423                    }
    424                    g_ed_time/=ed_count;//ed time is average value
    425                  }
    426                  else
    427                  {
    428                    g_ed_time=0;
    429                  }
    430                  
    431                  if(g_ed_time>=1440)
    432                    g_ed_time=1440;
    433                  
    434                  MemoryBank_Astro_UpdateEDonTime(0,g_ed_time);
                         ^
Warning[Pe223]: function "MemoryBank_Astro_UpdateEDonTime" declared implicitly
    435                  
    436                  if(update_flag==1)
    437                  {
    438                    g_nfc_flag_save=1;
    439                    
    440                    update_flag=0;
    441                  }
    442                  
    443                  index_flag=3;
    444                  
    445                  break;
    446                  
    447                case 3:
    448                   
    449                   nfc_local_state.fast_timer_cnt=0; // reset slow timer count
    450                   
    451                   if (I2cWrite(NFC_ED_TIME_ADRESS,test_data,24)==1)
    452                   {
    453                     ed_read=1;
    454                     AstroInit();
    455                   }
    456                     
    457                     break;
    458                  
    459              }
    460              
    461            }
    462            
    463            return ed_read;
    464            }
    465          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "nfc_ed_record"
    466          
    467          /*******************************************************************************
    468          
    469          /*******************************************************************************
                 ^
Warning[Pe009]: nested comment is not allowed
    470          * @Brief   AstroInit
    471          Ininization for Astro Dimming function
    472          Judge two modes. Then ini Astro counter value.
    473          * @Param   null
    474          * @Note    
    475          * @Return  0
    476          *******************************************************************************/
    477          uint16_t AstroInit(void)
    478          {
    479              uint32_t	ctime, center, ptime;
    480              uint16_t i;
    481              static uint8_t temp_read=0;
    482          #ifdef ENASTRO   
    483          	//  -------------------------------------------------------- get parameters
    484                  //MemoryBank_Astro_GetMode(0);        
    485                  MemoryBank_Astro_GetValue(6,(uint8_t *)&dimmer.mode,0) ; 
                         ^
Warning[Pe223]: function "MemoryBank_Astro_GetValue" declared implicitly
    486                  
    487                  MemoryBank_Astro_GetValue(12,&temp_read,0) ;    
    488                  MemoryBank_Astro_GetValue(13,(uint8_t *)&dimmer.duration[0],0) ; 
    489                  dimmer.duration[0]+=temp_read;
    490                  
    491                  MemoryBank_Astro_GetValue(15,&temp_read,0) ;
    492                  MemoryBank_Astro_GetValue(16,(uint8_t *)&dimmer.duration[1],0) ; 
    493                  dimmer.duration[1]+=temp_read<<8;
    494          //        
    495                  MemoryBank_Astro_GetValue(18,&temp_read,0) ;
    496                  MemoryBank_Astro_GetValue(19,(uint8_t *)&dimmer.duration[2],0) ;
    497                  dimmer.duration[2]+=temp_read<<8;
    498                  
    499                  MemoryBank_Astro_GetValue(21,&temp_read,0) ;
    500                  MemoryBank_Astro_GetValue(22,(uint8_t *)&dimmer.duration[3],0) ; 
    501                  dimmer.duration[3]+=temp_read<<8;
    502          	
    503                  dimmer.duration[4] = 0;
    504          	dimmer.duration[5] = 0;
    505          #ifdef FAST_TIME_ASTRO/*Fast Astro rate handle*/
    506              dimmer.duration[0]/=ASTRO_FAST_RATE;
    507              dimmer.duration[1]/=ASTRO_FAST_RATE;
    508              dimmer.duration[2]/=ASTRO_FAST_RATE;
    509              dimmer.duration[3]/=ASTRO_FAST_RATE;
    510              dimmer.duration[4]/=ASTRO_FAST_RATE;// FAST rate setting
    511          #endif
    512              /* Astro dimming level setting*/
    513              MemoryBank_Astro_GetValue(7,(uint8_t *)&dimmer.level[0],0);
    514              MemoryBank_Astro_GetValue(14,(uint8_t *)&dimmer.level[1],0);
    515              MemoryBank_Astro_GetValue(17,(uint8_t *)&dimmer.level[2],0);
    516              MemoryBank_Astro_GetValue(20,(uint8_t *)&dimmer.level[3],0);
    517              MemoryBank_Astro_GetValue(23,(uint8_t *)&dimmer.level[4],0);
    518              dimmer.level[5] = 30;  // minPhysicalLevel;
    519              /*Astro dimming fade time setting*/ 
    520              
    521              MemoryBank_Astro_GetValue(8,&temp_read,0) ;  
    522              MemoryBank_Astro_GetValue(9,(uint8_t *)&dimmer.fade[0],0);
    523              dimmer.fade[0]+=(temp_read<<8);					// in seconds (mem_bank_nfc.mem_bank_astro.Astro_startup_fade_h<<8)+
    524              MemoryBank_Astro_GetValue(10,(uint8_t *)&dimmer.fade[1],0);
    525              dimmer.fade[1]*=2;
    526              
    527              MemoryBank_Astro_GetValue(11,(uint8_t *)&dimmer.fade[5],0);
    528              dimmer.fade[5]*=15;					// warning 65535
    529              if(dimmer.fade[5]==0XEF1)//no fade switch off 
    530              {
    531                  dimmer.fade[5]=0X00;
    532                  dimmer.stepcounter[5] = 1;
    533              }
    534              else
    535              {
    536          #ifdef FAST_TIME_ASTRO
    537                  dimmer.stepcounter[5] =dimmer.fade[5]/5; // has switch off feature
    538          #else
    539                  dimmer.stepcounter[5] =dimmer.fade[5];
    540          #endif
    541              }
    542          #ifdef FAST_TIME_ASTRO
    543              dimmer.fade[0]/=5;
    544              dimmer.fade[1]/=5;
    545              dimmer.fade[5]/=5;  // Fade rate decrease 2 times
    546          #endif
    547          	dimmer.fade[2] = dimmer.fade[1];
    548          	dimmer.fade[3] = dimmer.fade[1];
    549          	dimmer.fade[4] = dimmer.fade[1];
    550               
    551          	// --------------------------------------------------------- on - time
    552              
    553          	dimEnable = 1;//Set dimming flag
    554          	dimStep = 0;  //set default dimStep
    555              
    556          	if (dimmer.mode  == 1) 
    557              {
    558                  // ------------------------------------------------------------------------- Astro Based
    559                  dimmer.ontimeED = g_ed_time; 										// history    ed time   
    560                  #ifdef 		FAST_TIME_ASTRO
    561                  //dimmer.ontimeED = g_ed_time/60; 										// FAST
    562                  #endif
    563                  //dimmer.duration[0]=12-dimmer.duration[0];//need to check how to get dim start time, need to remove
    564          		if (dimmer.ontimeED == 0) {
    565                      
    566          		  	dimEnable = 0; 														// NOT ed time ,dim - yes fade
    567          		    dimmer.fade[5] = PHASE_DISABLE_VALUE_U16;
    568                      
    569          			dimStep = 0;
    570          			dimmer.stepcounter[0] = (uint32_t)24 * 60 * 60;							// go Nominal
    571          			for (i=1; i <= 5; i++) {
    572          			    dimmer.stepcounter[i] = 0;	 									// no dimm. phases
    573            		    }
    574                      
    575          		} else 
    576                  {           
    577          		  	// ------------------------------------------------ absolute timing
    578                      center = dimmer.ontimeED >> 1;
    579          			dimmer.duration[0] = center - dimmer.duration[0];
    580                      //if (dimmer.duration[0] < 0) dimmer.duration[0] = - dimmer.duration[0];  // absolute
    581          	    }
    582                  
    583          	}
    584              else 
    585              {
    586                  // ------------------------------------------------------------------------- Time Based
    587                  
    588          	  	if (dimmer.duration[0] < 0) dimmer.duration[0] = - dimmer.duration[0];  // absolute
    589                  
    590          		dimmer.fade[5] = PHASE_DISABLE_VALUE_U16;
    591                  
    592          	}
    593              
    594          	if ( dimEnable ) 
    595              {       
    596                  ctime = 0;
    597                  for (i=0; i <= 3; i++)
    598                  {
    599                      ctime = ctime + dimmer.duration[i];
    600                      dimmer.stepcounter[i] = ctime * TIME_MULTIPLY ; 				// t2 .. t4
    601                  }
    602                  for (i=0; i <= 3; i++)
    603                  {									 		// t1 .. t4 >= 0
    604                      if ( dimmer.stepcounter[i] < dimmer.fade[0])
    605                      { 					// ti < startupFade
    606                          dimmer.stepcounter[i] = 0;
    607                          if(i!=4)
    608                          dimmer.fade[i+1]=dimmer.fade[0]; //change Astro_fade time with Start up fade time
    609                      }
    610                  }
    611                  // step0 = 0: no NomLev
    612                  // step1 = 0: no Lev 1 ...
    613                  // step2 = 0: no Lev 2 ...
    614                  // step3 = 0: no Lev 3 ...
    615                  
    616                  if (dimmer.fade[5] < PHASE_DISABLE_VALUE_U16) { 					// Switch off !
    617                      
    618                      dimmer.stepcounter[4] = (uint32_t)dimmer.ontimeED * TIME_MULTIPLY - dimmer.fade[5];	 	// t5
    619                      if (dimmer.stepcounter[4] < 10) dimmer.stepcounter[4] = 10;		// only for fast test. TBD
    620                      for (i=0; i <= 3; i++) 
    621                      {									 	// t1 .. t4  & t5
    622                          if ( (dimmer.stepcounter[i]+ dimmer.fade[1]) > dimmer.stepcounter[4])
    623                          { 		// ti + fade > t5
    624                              dimmer.stepcounter[i] = dimmer.stepcounter[4];
    625                          }
    626                      }
    627                  }
    628                  
    629                  // ---------------------------------------------- relative timing
    630                  ptime = dimmer.stepcounter[0];										// rel. t1
    631                  for (i=1; i <= 3; i++)
    632                  {											// rel. t2 .. t4
    633                      ctime = dimmer.stepcounter[i];
    634                      dimmer.stepcounter[i] = (ctime - ptime);           
    635                      ptime = ctime;
    636                  }
    637                  
    638                  if (dimmer.fade[5] < PHASE_DISABLE_VALUE_U16) {
    639                      
    640                      dimmer.stepcounter[4] = dimmer.stepcounter[4] - ptime;    		// rel. t5  (go fade)
    641                      
    642                  } else {
    643                      
    644                      dimmer.stepcounter[4] = (uint32_t)24 * 60 * 60; 						// no fade
    645                      
    646                  }
    647                  // t5 = EDtime - offFade > 4h - offFade > 3h
    648                  
    649                  // step3 = 0: no Lev 4 ...  stay on previous level
    650                  // step2 = 0: no Lev 3 ...
    651                  // step1 = 0: no Lev 2 ...
    652                  // step0 = 0: no Lev 1 ...
    653                  for(i=4;i>0;i--)//judge last non zero dimming level
    654                  {
    655                      if(dimmer.stepcounter[i] > 0)
    656                      {
    657                         last_dim_level=i; 
    658                         break;
    659                      }
    660                  }
    661                  dimStep = 0;       
    662                  for (i=0; i < 5; i++) 
    663                  {
    664                      if ( dimmer.stepcounter[i] > 0 ) 
    665                      {
    666                          dimStep = i; 												// dimStep 0 .. 4
    667                          dimFlag=1<<dimStep;
    668                          break;
    669                      }
    670                  }
    671                  
    672          	} // enabled
    673              
    674              
    675              //dimmer.presentLevel = dimmer.level[dimStep];
    676              
    677          	
    678              
    679              //SLOW_DaliDeviceSetLinearLevel( dimmer.level[dimStep], dimmer.fade[0] );	// fade n 0
    680              
    681              
    682          #endif   
    683          	return 0;
    684          }
    685          
    686          /*******************************************************************************
    687          * @Brief   AstroTimer
    688          * @Param   null
    689          * @Note    
    690          * @Return  0
    691          *******************************************************************************/
    692          uint16_t AstroTimer(void)
    693          {
    694              
    695          #define RUNCOUNT 200
    696              //bool newPdOverride;
    697              static uint8_t count=200;
    698              static uint8_t flag=0;
    699              static uint8_t astro_flag=0,astro_first=0;;
    700              static uint32_t dim_count=0;
    701              static uint32_t s_dim_percent=0;
    702              uint8_t i=0;
    703              uint16_t temp;
    704              static uint8_t  tx_buff[4];
    705              static uint8_t min_level_count=50;
    706              
    707              if(g_astro_flag)
    708              {
    709              if ( count++>=1)// every 1 second
    710              { 															        
    711                count=0;
    712                if(min_level_count++>50)
    713                {
    714                  min_level_count=0;
    715                  g_min_dim_level=Power_GetMinLevel();
    716                  //g_min_dim_level=4000;
    717                  for(i=0;i<6;i++)
    718                  {
    719                    if(dimmer.level[i]*100<g_min_dim_level)
    720                      dimmer.level[i]= (g_min_dim_level/100);
    721                  }
    722                }
    723                if (dimStep >= 5) 
    724                {
    725                  if(dimmer.mode == 1)//Astro Based
    726                  {
    727                    if(dimmer.fade[5]==0XEF1)// no swith off then keep level4
    728                      
    729                    {
    730                      return 0;									// >>>>>>>>>>>>>>  exit point !
    731                    }
    732                    
    733                    else   /*has switch off fade*/
    734                    {
    735                      if(dimmer.fade[5]!=0)//fade time is not 0
    736                      {
    737                        if(dim_count++<dimmer.fade[dimStep])
    738                        {
    739                          /*not first dimming level*/
    740                          temp=dimmer.level[last_dim_level]*100;
    741                          /*get last dimming level*/
    742                          if(g_min_dim_level>(dimmer.level[last_dim_level]*100))
    743                          {
    744                            /*calculate current setting dimming level, if is increase the value.*/
    745                            s_dim_percent=temp+((((g_min_dim_level))-temp)*dim_count)/dimmer.fade[5];
    746                            
    747                          }
    748                          else
    749                            
    750                          {
    751                            /*calculate current setting dimming level, if is decrease the value.*/
    752                            s_dim_percent=temp-((temp-((g_min_dim_level)))*dim_count)/dimmer.fade[5];
    753                            
    754                          }
    755                          /*update dimming level*/
    756                          Power_SetAstroDimmingLevel(s_dim_percent);
    757                          return 0;
    758                        }
    759                        else
    760                        {
    761                          dim_count=0;
    762                          dimmer.fade[5]=0;
    763                          return 0;
    764                        }
    765                      }
    766                      else
    767                      {
    768                        Power_SetAstroDimmingLevel(g_min_dim_level);
    769                        return 0;
    770                      }
    771                    }
    772                  }
    773                  else
    774                  {
    775                    return 0;// Time based no switch off feature.
    776                  }
    777                }
    778                
    779                if(dimFlag==(1<<dimStep)&&flag==0)
    780                {
    781                  
    782                  flag=1;// flag for current Step
    783                  
    784                  dimFlag=0;
    785                  
    786                  astro_flag=1;// flag for Astro dimming counter at current dimming step
    787                  
    788                }
    789                if(flag)
    790                {
    791                  if ( dimmer.stepcounter[ dimStep ]>=0)
    792                  {
    793                    /*counter couting*/
    794                    dimmer.stepcounter[dimStep]-=1 ;   
    795                    
    796                    if(astro_flag==1)  
    797                    {   
    798                      if(dimmer.fade[dimStep]<=0)
    799                      {
    800                        dimmer.fade[dimStep]=1;//make sure the fade time is not zero
    801                      }
    802                      /*Astro dimming handle*/
    803                      if(dim_count++<dimmer.fade[dimStep])
    804                      {
    805                        /*level change within the fade time*/
    806                        if(astro_first==0)
    807                        {
    808                          /*if it is first dimming step*/
    809                          temp=g_min_dim_level;
    810                          /*calculate dimming level linear change rate based on fade time*/
    811                          if(temp<(dimmer.level[dimStep]*100))// if level is bigger than samllest level
    812                          {
    813                            s_dim_percent=temp+((((dimmer.level[dimStep])*100)-temp)*dim_count)/dimmer.fade[dimStep];
    814                          }
    815                          else
    816                          {  /* min level is bigger than set value, set min value directly.*/
    817                            s_dim_percent=temp;//3000+((temp-3000)*dim_count)/dimmer.fade[dimStep];//need to check
    818                          }
    819                          /*update PWM*/
    820                          Power_SetAstroDimmingLevel(s_dim_percent);
    821                          
    822                        }
    823                        else
    824                        {   
    825                          /*not first dimming level*/
    826                          temp=dimmer.level[dimStep-1]*100;
    827                          /*get last dimming level*/
    828                          if(dimmer.level[dimStep]>dimmer.level[dimStep-1])
    829                          {
    830                            /*calculate current setting dimming level, if is increase the value.*/
    831                            s_dim_percent=temp+((((dimmer.level[dimStep])*100)-temp)*dim_count)/dimmer.fade[dimStep];
    832                            
    833                          }
    834                          else
    835                            
    836                          {
    837                            /*calculate current setting dimming level, if is decrease the value.*/
    838                            s_dim_percent=temp-((temp-((dimmer.level[dimStep])*100))*dim_count)/dimmer.fade[dimStep];
    839                            
    840                          }
    841                          /*update dimming level*/
    842                          Power_SetAstroDimmingLevel(s_dim_percent);
    843                        }
    844                      }
    845                      else
    846                      {
    847                        /*fade time is over, wait current phase time over*/
    848                        if(astro_first==0)
    849                        {
    850                          /*clear first dimming flag*/
    851                          astro_first=1;
    852                          
    853                        }
    854                        /*reset counter value*/
    855                        dim_count=0;
    856                        /*reset astro dimming step flag*/
    857                        astro_flag=0;
    858                      }
    859                    }
    860                    
    861                  }
    862                  else
    863                  {
    864                    /* current setp counter is over*/
    865                    if ( dimmer.stepcounter[dimStep] <= 0)
    866                    {
    867                      /*move to next step*/
    868                      dimStep++;
    869                      /*max step num is 5*/
    870                      if (dimStep > 5) dimStep = 5;
    871                      flag=0;
    872                      /* clear flag for current setp astro dimming*/
    873                      dimFlag=(1<<dimStep);
    874                      /*move to next dimflag*/
    875                      dim_count=0;
    876                      /*clear dim_count*/
    877                      astro_flag=0;
    878                      /*clear current step dimming falg*/
    879                    }
    880                  }
    881                }              
    882              } 
    883              else
    884              {
    885                 if (getMainsTimerMinutes() >= H24_CYCLE_MINUTES&&(dimmer.mode  == 1))// >>>  24 h TEST <<<<<<<<<<
    886                {
    887                  /*nfc is idle*/
    888                    
    889                    if((I2cAreAllPendingTransfersDone()==1)&&nfc_local_state.fsm_state==nfc_fsm_state_idle)
    890                  {
    891                    nfc_local_state.fast_timer_cnt=0; // reset slow timer count
    892                    tx_buff[3]=g_nfc_time>>24;
    893                    tx_buff[2]=(uint8_t)(g_nfc_time>>16);
    894                    tx_buff[1]=(uint8_t)(g_nfc_time>>8);
    895                    tx_buff[0]=(uint8_t)g_nfc_time;
    896                    if (I2cWrite(NFC_ED_TIME_ADRESS+4,tx_buff,4)==1)// (M24LRxx_WriteBuffer(NFC_RUNTIME_PRE,4,g_nfc_time)!=I2C_CODE_OK) //invalid on-time  and clear current working time      				                   
    897                    {
    898                      /*Reset current on time*/
    899                      g_last_ontime=g_nfc_time;
    900                      AstroInit(); 						// restart Astro !        
    901                      /*reset astro dimming first flag*/
    902                      astro_first=0;
    903                    }
    904                  }
    905                }
    906              }
    907              return 0;
    908              }
    909          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "AstroTimer"
    910          /*******************************************************************************
    911          * @Brief   getMainsTimerMinutes
    912          Return current power on time in minutes
    913          * @Param   null
    914          * @Note    
    915          * @Return  on time in minutes
    916          *******************************************************************************/
    917          /*******************************************************************************/
    918          uint16_t getMainsTimerMinutes() 
    919          {
    920              return ((g_nfc_time-g_last_ontime)/60);
    921          }
    922          /*******************************************************************************
    923          * @Brief   nfc_nvm_time_write
    924          save time in nvm and judge if time in tag is right or not, if no update with nvm value
    925          * @Param   null
    926          * @Note    
    927          * @Return 
    928          *******************************************************************************/
    929          void nfc_nvm_time_write(void)
    930          {   
    931              
    932              if(abs(g_nfc_time-g_time_nvm_pre)>(2*NVM_TIME_SAVE_PERIOD))//judge g_nfc_time data range in right range
                        ^
Warning[Pe223]: function "abs" declared implicitly
    933              {
    934                  g_nfc_time=g_time_nvm_pre;
    935              }
    936              else
    937              {
    938                  
    939                  if((g_nfc_time-g_time_nvm_pre)>NVM_TIME_SAVE_PERIOD)//judge if time is more than 10h
    940                  {
    941                      
    942                      g_flag_flash_write=1;
    943                      
    944                      g_time_nvm_pre=g_nfc_time;// reset g_time_nvm_pre 
    945                      
    946                  }
    947              }
    948              
    949          }
    950          /*******************************************************************************
    951          * @Brief   nfc_eol_handle
    952          hanlde eol feature 
    953          * @Param   null
    954          * @Note    
    955          * @Return 
    956          *******************************************************************************/
    957          void nfc_eol_handle(void) //call every 500ms
    958          {
    959              static uint8_t eol_flag=0;// 0: default ;1: no eol; 2; eol is enable 3; eol handle is ongoing; 4:eol handle is finished
    960              static uint32_t time_cout=0;
    961              if(eol_flag==0)
    962              {
    963                  if(MemoryBank_EOL_GetEnable(0)==1)//(mem_bank_nfc.mem_bank_eol.Eol_enable==0x01)//eol is enable
                            ^
Warning[Pe223]: function "MemoryBank_EOL_GetEnable" declared implicitly
    964                  {
    965                      if(g_nfc_time>(MemoryBank_EOL_GetEOLtime(0)*3600*1000))
                                            ^
Warning[Pe223]: function "MemoryBank_EOL_GetEOLtime" declared implicitly
    966                      {
    967                          eol_flag=2;
    968                      }
    969                  }
    970                  else
    971                  {
    972                      eol_flag=1;
    973                  }
    974              }
    975              else
    976              {
    977                  if(eol_flag==2)
    978                  {
    979                      Power_SetEolDimmingLevel(2500);//set to 25%
    980                      eol_flag=3; //handling 
    981                  }
    982                  if(eol_flag==3)
    983                  {
    984                      if(time_cout++>=(60*2))//1min
    985                      {
    986                          eol_flag=4;//finished eol handle
    987                          MemoryBank_Eol_UpdateStatus(0,1);//mem_bank_nfc.mem_bank_eol.Eol_status=0x01;
                                 ^
Warning[Pe223]: function "MemoryBank_Eol_UpdateStatus" declared implicitly
    988                          Power_SetEolDimmingLevel(10000);//set to 100%
    989                          time_cout=0;
    990                      }
    991                  }
    992              }
    993              
    994          }
    995          /*******************************************************************************
    996          * @Brief   nfc_flash_write
    997          save time in nvm and judge if time in tag is right or not, if no update with nvm value
    998          * @Param   null
    999          * @Note    
   1000          * @Return 
   1001          *******************************************************************************/
   1002          void nfc_flash_write(void)
   1003          {
   1004              static uint32_t s_data[4];
   1005              uint8_t i;
   1006              
   1007              if(g_flag_flash_write)
   1008              {
   1009                  g_flag_flash_write=0;
   1010                  
   1011                  crcReset();
                         ^
Warning[Pe223]: function "crcReset" declared implicitly
   1012                  
   1013                  s_data[0]=g_nfc_time;
   1014                  /*reset crc value*/
   1015                  for(i=0;i<4;i++)
   1016                  {
   1017                      
   1018                      crcLoadByte(*((uint8_t*)s_data+i));
                             ^
Warning[Pe223]: function "crcLoadByte" declared implicitly
   1019                      /*calculate crc value*/
   1020                  }
   1021                  s_data[1]=crcGet();
                                   ^
Warning[Pe223]: function "crcGet" declared implicitly
   1022                  SysTick->CTRL=0X00;//close systick
   1023                  //__disable_interrupt();// disable all interrupt
   1024                  
   1025                  XMC_FLASH_ProgramVerifyPage((uint32_t*)FLASH_TIME_ADDRESS,s_data);
   1026            
   1027                  //SysTick_Config(SYSCLK_Hz / SYSTICK_INT_Hz);//open systick
   1028                 // __enable_interrupt();// enable all interrupt   
   1029              }
   1030          }
   1031          /******************************************************************************/
   1032          void nfc_time_hanlde()
   1033          {
   1034            uint8_t temp_mode=0;
   1035            extern uint8_t g_nfc_tag_read;
   1036            uint32_t temp;
   1037            
   1038            if(nfc_local_state.fsm_state==nfc_fsm_state_idle&&I2cAreAllPendingTransfersDone())
   1039            {
   1040              switch (g_nfc_tag_read)
   1041              {
   1042              case 2:
   1043                
   1044                if(nfc_time_id()==1)
   1045                {
   1046                  
   1047                  temp=(ConstantLumen_GetFactor(0)*10000);
                               ^
Warning[Pe223]: function "ConstantLumen_GetFactor" declared implicitly
   1048                  
   1049                  temp=temp>>14;
   1050                  
   1051                  Power_SetConstantLumenValue(temp);
   1052                  
   1053                  g_nfc_tag_read=3;
   1054                }
   1055                
   1056                
   1057                
   1058                break;
   1059                
   1060              case 3:
   1061                
   1062                MemoryBank_Astro_GetValue(6,(uint8_t *)&temp_mode,0) ;
                       ^
Warning[Pe223]: function "MemoryBank_Astro_GetValue" declared implicitly
   1063                if(temp_mode==1)
   1064                {
   1065                  if(nfc_ed_record()==1)
   1066                  {
   1067                    
   1068                    g_nfc_tag_read=4;
   1069                    
   1070                    g_astro_flag=1;
   1071                    
   1072                  }
   1073                }
   1074                else
   1075                {
   1076                  if(temp_mode==5)//time based mode
   1077                  {
   1078                    AstroInit();
   1079                    
   1080                    g_astro_flag=1;
   1081                    
   1082                  }
   1083                  g_nfc_tag_read=4;
   1084                }
   1085                
   1086                break;
   1087                
   1088              case 4:
   1089                
   1090                 nfc_time_record();
   1091                 
   1092                 nfc_eol_handle();
   1093                
   1094                break;
   1095                
   1096              default:
   1097                break;
   1098              }
   1099            }
   1100          }
   1101          #endif /* MODULE_NFC */
   1102          
   1103          /** @}  End of group HW */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AstroInit
         8   -> MemoryBank_Astro_GetValue
       8   AstroTimer
         8   -> AstroInit
         8   -> I2cAreAllPendingTransfersDone
         8   -> I2cWrite
         8   -> Power_GetMinLevel
         8   -> Power_SetAstroDimmingLevel
         8   -> getMainsTimerMinutes
         8 __aeabi_idiv
         8 __aeabi_uidiv
       4   getMainsTimerMinutes
         4 __aeabi_uidiv
       8   nfc_ed_record
         8   -> AstroInit
         8   -> I2cCyclic
         8   -> I2cRead
         8   -> I2cWrite
         8   -> MemoryBank_Astro_GetStartEDontime
         8   -> MemoryBank_Astro_UpdateEDonTime
         8 __aeabi_uidiv
       8   nfc_eol_handle
         8   -> MemoryBank_EOL_GetEOLtime
         8   -> MemoryBank_EOL_GetEnable
         8   -> MemoryBank_Eol_UpdateStatus
         8   -> Power_SetEolDimmingLevel
       8   nfc_flash_write
         8   -> XMC_FLASH_ProgramVerifyPage
         8   -> crcGet
         8   -> crcLoadByte
         8   -> crcReset
       8   nfc_nvm_time_write
         8   -> abs
       8   nfc_time_hanlde
         8   -> AstroInit
         8   -> ConstantLumen_GetFactor
         8   -> I2cAreAllPendingTransfersDone
         8   -> MemoryBank_Astro_GetValue
         8   -> Power_SetConstantLumenValue
         8   -> nfc_ed_record
         8   -> nfc_eol_handle
         8   -> nfc_time_id
         8   -> nfc_time_record
     104   nfc_time_id
       104   -> I2cRead
       104   -> InfoMPC_GetLampOnMinutes
       104   -> MemoryBank_Info_SetMinute_value
       104   -> abs
       104 __aeabi_uidiv
       8   nfc_time_record
         8   -> I2cAreAllPendingTransfersDone
         8   -> I2cWrite


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     892  AstroInit
    1074  AstroTimer
       1  astro_first
       1  astro_flag
       1  count
       1  dimEnable
       1  dimFlag
       1  dimOverride
       1  dimStep
       4  dim_count
      92  dimmer
       1  ed_count
       1  ed_index
       1  ed_read
       1  eol_flag
       1  flag
       1  flag_t4t_update
       1  g_astro_flag
       4  g_ed_time
       1  g_flag_flash_write
       8  g_gtin_num
       1  g_inf_time_update
       4  g_last_ontime
       2  g_min_dim_level
       1  g_moble_flag
       1  g_nfc_current_percent
       1  g_nfc_current_set
       1  g_nfc_dim_percent
       4  g_nfc_fast_save_time
       1  g_nfc_flag_pwm
       1  g_nfc_flag_record
       1  g_nfc_flag_record
       1  g_nfc_flag_save
       4  g_nfc_time
       1  g_nfc_time_id
       1  g_nfc_update_flag
       1  g_psw_update_flag
       1  g_pwm_update_flag
       4  g_time_nvm_pre
      22  getMainsTimerMinutes
       1  i
       1  id_index
       1  index_flag
       1  index_flag
       1  index_read
       1  last_dim_level
       1  min_level_count
     718  nfc_ed_record
     126  nfc_eol_handle
      74  nfc_flash_write
      64  nfc_nvm_time_write
     154  nfc_time_hanlde
     394  nfc_time_id
     154  nfc_time_record
       1  read_flag
       1  read_flag
       4  runtime_pre
      96  s_arr
      16  s_data
       4  s_dim_percent
       1  temp_read
      24  test_data
       4  time_cout
       1  time_id_flag
       4  time_save
       4  tx_buff
       1  update_flag

 
   308 bytes in section .bss
     6 bytes in section .data
     8 bytes in section .rodata
 3 976 bytes in section .text
 
 3 976 bytes of CODE  memory
     8 bytes of CONST memory
   314 bytes of DATA  memory

Errors: none
Warnings: 27
