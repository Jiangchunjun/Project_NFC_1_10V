###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.1.11864/W32 for ARM       03/Apr/2019  11:37:54
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\tag.c
#    Command line =  
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\tag.c" -D
#        XMC1301_T038x0064 -D OT_NFC_IP67_200W -D NDEBUG -D ENABLT_WDT -D
#        ENABLE_COMM -D ENABLE_USART -D nDEBUG_PRINT -D nDEBUG_VERSION -D
#        MODULE_I2C -D MODULE_M24LRxx -D MODULE_NFC -D MODULE_NFC_DALI -D
#        ENASTRO -D NO_FAST_TIME_ASTRO -D NO_EN_CLM_TIME_FAST -D ENABLE_OVP -D
#        ENABLE_MOBILE -D ENABLE_ONE2TEN -D BYTEORDER_LITTLE_ENDIAN -D
#        AVAILABLE_PORTS_NUMBER=3 -D FW_HIGH=01 -D FW_LOW=02 -D ENASTRO -D
#        MPC_O2T_DEFAULT_SETTINGS -D MPC_O2T_DEFAULT_BOUNDARIES -lc "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List" -o "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\IAR ARM
#        7.8\arm\INC\c\DLib_Config_Normal.h" -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\XMC_Peripheral_Library\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\inc\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Driver\inc\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\devices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\Config\" -I "C:\C
#        Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\driver_ot\" -I
#        "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\fileTank\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\I2cExt\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Import\modules\NfcExt\M24LRxx\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\"
#        -I PROJ_DIR$\..\Application\src\modules\NVM\api\ -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\driver_xmc1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC\driver_api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\currentset\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\DaliServices\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\HW\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Modules\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Optional\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\Dali\iFace\Services\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Acl\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Alloc\Legacy\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Clm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Csm\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Info\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSK\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\O2T\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\AstroDim\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\MSKEncryption\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\Power\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\MPC\EOL\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NFC\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\I2C\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\XMCLib\inc\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\XMCLib\CMSIS\Infineon\XMC1300_series\Include\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\CRC16\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\hwdrivers\XMC1300\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\NVM\api\"
#        -I "C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\..\Application\src\modules\supplymonitor\"
#        -Ol
#    Locale       =  Chinese (Simplified)_CHN.936
#    List file    =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\List\tag.lst
#    Object file  =  
#        C:\C Pan\work\NFC
#        1-10\NFC2_1_10V\Project_NFC_1_10V\IAR_Proj\output\200W\Obj\tag.o
#
###############################################################################

C:\C Pan\work\NFC 1-10\NFC2_1_10V\Project_NFC_1_10V\Application\src\tag.c
      1          /*
      2          ***************************************************************************************************
      3          *                            NFC Tag M24LRxx EEPROM Operation Functions
      4          *                            M24LRxx series macro define and interface
      5          *
      6          * File   : tag.c
      7          * Author : Douglas Xie
      8          * Date   : 2016.03.18
      9          ***************************************************************************************************
     10          * Copyright (C) 2016 OSRAM Asia Pacific Management Company.  All rights reserved.
     11          ***************************************************************************************************
     12          */
     13          
     14          #ifdef DEBUG_VERSION
     15          
     16          /* Include Head Files ---------------------------------------------------------------------------*/
     17          #include "tag.h"
     18          
     19          /* Macro Defines --------------------------------------------------------------------------------*/
     20          
     21          
     22          /* Global Variable ------------------------------------------------------------------------------*/
     23          
     24          
     25          /* Function Declaration -------------------------------------------------------------------------*/
     26          
     27          
     28          
     29          /* Function Implement ---------------------------------------------------------------------------*/
     30          
     31          
     32          /****************************************************************************
     33          @Brief      TAG Ack Polling to Get I2C Bus Priority
     34          @Param[in]  timeout | Ack polling times limited, 0 is no limited
     35          @Param[out] 
     36          @Note       
     37          @Return     Return TRUE if TAG is available, otherwise return FALSE
     38          ****************************************************************************/
     39          uint8_t Tag_AckPolling(uint16_t timeout)
     40          {
     41              uint16_t result = FALSE;            /* Device default state is not available */
     42              uint16_t flag;
     43              
     44              if( timeout == 0 )
     45              {
     46                  while(1)
     47                  {
     48                      flag = I2C_IsBusy( TAG_ADDRESS );
     49                      
     50                      if( flag == FALSE )        /* Device is not busy, so it's available */
     51                      {
     52                          result = TRUE;
     53                          break;
     54                      }
     55                  }
     56              }
     57              else
     58              {
     59                  while( timeout-- > 0 )
     60                  {
     61                      flag = I2C_IsBusy( TAG_ADDRESS );
     62                      
     63                      if( flag == FALSE )        /* Device is not busy, so it's available */
     64                      {
     65                          result = TRUE;
     66                          break;
     67                      }
     68                  }
     69              }
     70              
     71              return result;
     72          }
     73          
     74          
     75          /****************************************************************************
     76          @Brief      Read Data from EEP TAG
     77          @Param[in]  start_addr | Read data from EEP from this address
     78          @Param[in]  length | the number of data that want to read
     79          @Param[out] pdata | Return datas that read from EEP
     80          @Note       if length out of range, it will be cut off
     81          @Return     return OK when read data success or return ERROR
     82          ****************************************************************************/
     83          uint8_t Tag_ReadEEP(uint16_t start_addr, uint16_t length, uint8_t *pdata )
     84          {
     85              uint16_t result;
     86              
     87              /* if length out of range, it will be cut off */
     88              if(( start_addr + length ) > TAG_EEPROM_SIZE )
     89              {
     90                  length = TAG_EEPROM_SIZE - start_addr;
     91              }
     92              
     93              result = I2C_ReadData( TAG_ADDRESS, start_addr, length, pdata );
     94              
     95              return result;
     96          }
     97          
     98          
     99          /****************************************************************************
    100          @Brief      Write Data to EEP TAG
    101          @Param[in]  start_addr | Write data to EEP from this address
    102          @Param[in]  length | the number of data that want to write
    103          @Param[in]  pdata | Target datas that will write to EEP
    104          @Param[out]  
    105          @Note       Provide solution to solve the TAG EEP limit that one I2C\n
    106          write command can only write one block( 4 bytes ) data.
    107          <br>    if length out of range, it will be cut off
    108          @Return     return OK when read data success or return ERROR
    109          ****************************************************************************/
    110          uint8_t Tag_WriteEEP( uint16_t start_addr, uint16_t length, uint8_t *pdata )
    111          {
    112              uint16_t result = OK;
    113              uint16_t block_num_1;
    114              uint16_t block_num_2;
    115              uint16_t block_num_3;
    116              
    117              /* if length out of range, it will be cut off */   
    118              if(( start_addr + length ) > TAG_EEPROM_SIZE )
    119              {
    120                  length = TAG_EEPROM_SIZE - start_addr;
    121              }
    122              
    123              block_num_1 = 4 - start_addr % 4;            /* first block available byte number */
    124              block_num_2 = ( length - block_num_1 ) / 4;  /* full write block number */
    125              block_num_3 = ( length - block_num_1 ) % 4;  /* last block left byte number */
    126              
    127              if( length <= block_num_1)
    128              {
    129                  result = I2C_WriteData( TAG_ADDRESS, start_addr, length, pdata );
    130              }
    131              else 
    132              {
    133                  result = I2C_WriteData( TAG_ADDRESS, start_addr, block_num_1, pdata );
    134                  
    135                  if( result == OK )
    136                  {
    137                      pdata += block_num_1;
    138                      start_addr += block_num_1;
    139                      
    140                      for( ; block_num_2 > 0; block_num_2-- )
    141                      {
    142                          result = I2C_WriteData( TAG_ADDRESS, start_addr, 4, pdata );
    143                          
    144                          if( result == OK )
    145                          {
    146                              pdata += 4;
    147                              start_addr += 4;
    148                          }
    149                          else
    150                          {
    151                              result = ERROR;
    152                              break;
    153                          }
    154                      }
    155                      
    156                      if(( result == OK ) && ( block_num_3 > 0 ))
    157                      {
    158                          result = I2C_WriteData( TAG_ADDRESS, start_addr, block_num_3, pdata );
    159                      }
    160                  }
    161              }
    162              
    163              return result;
    164          }
    165          
    166          
    167          /****************************************************************************
    168          @Brief      Submit I2C Password to TAG
    169          @Param[in]  enable_flag | ENABLE or DISABLE
    170          @Param[out] 
    171          @Note       if enable_flag is TRUE, then submit the right password,\n
    172                      otherwise submit the wrong password to remain TAG locked
    173          <br>        it needs delay time to compare password after submit finish
    174          @Return     Return OK if submit password success, otherwise return ERROR 
    175          ****************************************************************************/
    176          uint8_t Tag_SubmitPassword( uint8_t enable_flag )
    177          {
    178              uint8_t i;
    179              uint16_t result;
    180              union password_t send_password;
    181              uint8_t cmd_buffer[9] = { 0,0,0,0, TAG_SUBMIT, 0,0,0,0 };
    182              
    183              /* this password can be save to MCU internal eeprom */
    184              send_password.password = TAG_PASSWORD;  
    185              
    186              if( enable_flag == ENABLE )
    187              {
    188                  for( i = 0; i < 4; i++ )
    189                  {
    190                      cmd_buffer[i]     = send_password.array[i];
    191                      cmd_buffer[i + 5] = send_password.array[i];            
    192                  }
    193              }
    194              else
    195              {
    196                  for( i = 0; i < 4; i++ )
    197                  {
    198                      cmd_buffer[i]     = 0;//send_password.array[i] + 2;
    199                      cmd_buffer[i + 5] = 0;//send_password.array[i] + 2;            
    200                  }
    201              }
    202              
    203              result = I2C_WriteData( TAG_ADDRESS_E2, TAG_PASSWORD_ADDR, 9, cmd_buffer );
    204              
    205              return result;
    206          }
    207          
    208          
    209          /****************************************************************************
    210          @Brief      Change I2C Password of TAG
    211          @Param[in]  new_password | 32bit unsigned value
    212          @Param[out] 
    213          @Note       should submit the right password before call this function 
    214          <br>        it needs delay time to compare password after write finish
    215          @Return     Return OK if write password success, otherwise return ERROR 
    216          ****************************************************************************/
    217          uint8_t TAG_ChangePassword( uint32_t new_password )
    218          {
    219              uint8_t i;
    220              uint16_t result;
    221              union password_t send_password;
    222              uint8_t cmd_buffer[9] = { 0,0,0,0, TAG_CHANGE, 0,0,0,0 };
    223              
    224              /* suggestion: after change new Password, MCU should save to internal eeprom */
    225              send_password.password = new_password; 
    226              
    227              for( i = 0; i < 4; i++ )
    228              {
    229                  cmd_buffer[i]     = send_password.array[i];
    230                  cmd_buffer[i + 5] = send_password.array[i];   
    231              }
    232              
    233              result = I2C_WriteData( TAG_ADDRESS_E2, TAG_PASSWORD_ADDR, 9, cmd_buffer );
    234              
    235              /* Here should add some propriate steps to save the new password */
    236              //if( result == OK )
    237              //{
    238              //    FlashWrite(...)
    239              //}
    240              
    241              return result;
    242          }
    243          
    244          
    245          /****************************************************************************
    246          @Brief      Config EEP to Setup RF WIP/BUSY Pin Interrupt Mode
    247          @Param[in]  mode | TAG_RF_WIP or TAG_RF_BUSY
    248          @Param[out] 
    249          @Note       TAG_RF_WIP: 
    250          <br>        TAG_RF_BUSY:
    251          @Return     Return OK if config success, otherwise return ERROR 
    252          ****************************************************************************/
    253          uint8_t Tag_ConfigInterrupt( uint8_t mode )
    254          {
    255              uint16_t result;
    256              uint8_t config;
    257              
    258              result = I2C_ReadData( TAG_ADDRESS_E2, TAG_WIP_BUSY_ADDR, 1, &config );
    259              
    260              if( result == OK )
    261              {
    262                  if( mode == TAG_RF_WIP )
    263                  {
    264                      config |= 0x08;           /* Set WIP/BUSY bit to select WIP */
    265                  }
    266                  else
    267                  {
    268                      config &= ~0x08;          /* Reset WIP/BUSY bit to select BUSY */
    269                  }
    270                  result = I2C_WriteData( TAG_ADDRESS_E2, TAG_WIP_BUSY_ADDR, 1, &config );
    271              }
    272              
    273              return result;
    274          }
    275          
    276          
    277          /****************************************************************************
    278          @Brief      Config EEP to Open/Close Energy Harvest
    279          @Param[in]  enable_flag | ENABLE or DISABLE
    280          @Param[in]  config | there are 4 output mode
    281          @Param[out] 
    282          @Note       if enable_flag is ENABLE then open Energy Harvest, otherwise closed
    283          @Return     Return OK if config success, otherwise return ERROR 
    284          ****************************************************************************/
    285          uint8_t Tag_ConfigEH( uint8_t enable_flag, uint8_t EH_config )
    286          {
    287              uint16_t result;
    288              uint8_t  config1;
    289              uint8_t  config2;
    290              
    291              result = I2C_ReadData( TAG_ADDRESS_E2, TAG_WIP_BUSY_ADDR, 1, &config1 );
    292              
    293              if( result == OK )   
    294              {
    295                  result = I2C_ReadData( TAG_ADDRESS_E2, TAG_EH_ADDR, 1, &config2 );
    296                  
    297                  if( result == OK )
    298                  {
    299                      if( enable_flag == ENABLE )
    300                      {
    301                          /*  */
    302                          config1 &= ~0x07;             /* Bit2 EH_mode = 0, Reset Bit1, Bit0 */
    303                          config1 |= EH_config;         /* Config Bit1, Bit0*/
    304                          config2 |= 0x01;              /* Bit0 EH_enable = 1 */
    305                      }
    306                      else
    307                      {
    308                          config1 &= ~0x03;             /* Reset Bit1, Bit0 */
    309                          config1 |= 0x04 + EH_config;  /* Bit2 EH_mode = 1, Config Bit1, Bit0*/
    310                          config2 &= ~0x01;             /* Bit0 EH_enable = 0 */
    311                      }
    312                      
    313                      result = I2C_WriteData( TAG_ADDRESS_E2, TAG_WIP_BUSY_ADDR, 1, &config1 );
    314                      
    315                      if( result == OK )
    316                      {
    317                          result = I2C_WriteData( TAG_ADDRESS_E2, TAG_EH_ADDR, 1, &config2 );
    318                      }
    319                  }
    320              }
    321              
    322              return result;
    323          }
    324          
    325          #endif /* DEBUG_VERSION */


 

 


Errors: none
Warnings: none
